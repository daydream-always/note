简要讲解Java构造器的知识点，并说明这些知识在实际开发有哪些应用场景

### 1. 构造器基本概念

**定义**：构造器是Java类中一种特殊的方法，用于创建对象时初始化对象状态。

**特点**：

- 方法名与类名完全相同
- 没有返回类型（连void都不写）
- 创建对象时自动调用
- 每个类至少有一个构造器

### 2. 构造器的分类

// 无参构造器
public Student() {
    this.name = "Unknown";
    this.age = 0;
}

// 有参构造器
public Student(String name, int age) {
    this.name = name;
    this.age = age;
}

<font color="red">// 构造器重载</font>
public Student(String name) {
    this(name, 0);
}

public Student(int age) {
    this("Unknown", age);
}

### 3. this关键字在构造器中的使用

public class Person {
    private String name;
    private int age;
    

public Person(String name, int age) {
    this.name = name;  // this引用当前对象
    this.age = age;
}

// 构造器调用另一个构造器
public Person(String name) {
    this(name, 0);  // 必须是第一行
}

}

### 4. 构造器的调用顺序

class Parent {
    public Parent() {
        System.out.println("父类构造器");
    }
}

class Child extends Parent {
    public Child() {
        super();  // 调用父类构造器（可省略）
        System.out.println("子类构造器");
    }
}

### 5. 静态块与构造器执行顺序

静态块 -> 构造器



## 实际开发应用场景

### 1. **对象初始化**

```Java
public class DatabaseConnection {
    private String url;
    private String username;
    private String password;
    
    // 构造器确保对象创建时就有完整的信息
    public DatabaseConnection(String url, String username, String password) {
        this.url = url;
        this.username = username;
        this.password = password;
    }
}
```

### 2. **参数验证**

```Java
public class User {
    private String email;
    private int age;
    
    public User(String email, int age) {
        if (email == null || email.isEmpty()) {
            throw new IllegalArgumentException("邮箱不能为空");
        }
        if (age < 0) {
            throw new IllegalArgumentException("年龄不能为负数");
        }
        this.email = email;
        this.age = age;
    }
}
```

### 3. **默认值设置**

```Java
public class Product {
    private String name;
    private double price;
    private int stock;
    
    // 提供多种构造器，方便不同场景使用
    public Product() {
        this.name = "未知商品";
        this.price = 0.0;
        this.stock = 0;
    }
    
    public Product(String name) {
        this();
        this.name = name;
    }
    
    public Product(String name, double price) {
        this(name);
        this.price = price;
    }
}
```

### 4. **工厂模式实现**

```Java
public class ShapeFactory {
    // 构造器私有化，防止外部直接创建
    // 目的：禁止外部通过 new ShapeFactory() 创建工厂实例，因为工厂方法全部是 static，无需实例化即可调用。
    private ShapeFactory() {}
    
    public static Shape createCircle(double radius) {
        return new Circle(radius);
    }
    
    public static Shape createRectangle(double width, double height) {
        return new Rectangle(width, height);
    }
}
```

这段代码实现的是简单工厂模式（不属于 GoF 23 种经典设计模式，但属于工厂模式的基础变体），核心是通过一个工厂类统一创建不同类型的产品对象，对外屏蔽对象创建的细节。

### 5. **配置对象创建**

```Java
public class AppConfig {
    private String databaseUrl;
    private int port;
    private boolean debug;
    
    public AppConfig(String databaseUrl, int port, boolean debug) {
        this.databaseUrl = databaseUrl;
        this.port = port;
        this.debug = debug;
    }
    
    // 提供便捷的配置方法
    public static AppConfig defaultConfig() {
        return new AppConfig("localhost:3306", 8080, false);
    }
}
```

### 6. **依赖注入场景**

```Java
public class UserService {
    private UserRepository userRepository;
    private EmailService emailService;
    
    // 通过构造器注入依赖
    public UserService(UserRepository userRepository, EmailService emailService) {
        this.userRepository = userRepository;
        this.emailService = emailService;
    }
}
```

### 7. **不可变对象创建**

```Java
public class Point {
    private final int x;
    private final int y;
    
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    // 只提供getter，确保对象不可变
    public int getX() { return x; }
    public int getY() { return y; }
}
```

### 8. **链式调用模式**<font color="red">（不好理解）</font>

```Java
public class StringBuilder {
    private StringBuilder builder;
    
    public StringBuilder() {
        this.builder = new StringBuilder();	
    }
    
    public StringBuilder append(String str) {
        this.builder.append(str);
        return this;  // 返回当前对象，支持链式调用
    }
    
    public String toString() {
        return builder.toString();
    }
}
```

### 9. **单例模式实现**<font color="red">（重点）</font>

```Java
public class Singleton {
    private static Singleton instance;
    
    // 私有构造器，防止外部创建
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

这个为什么叫单例模式，为什么需要这个模式

典型应用场景举例

框架层面：Spring 容器中的「默认单例 Bean」（默认情况下，Spring 的 Bean 都是单例，节省内

存 + 保证状态一致）；

工具类：日志框架（如 log4j2 的 LoggerContext）、配置解析工具（如 PropertiesUtil）；

资源管理：数据库连接池（Druid、HikariCP）、线程池（ExecutorService）；

系统服务：操作系统的任务管理器、桌面窗口管理器（整个系统只有一个实例）。

### 10. **实体类创建**

```Java
public class Order {
    private String orderId;
    private List<OrderItem> items;
    private LocalDateTime createTime;
    private double totalAmount;
    
    // 构造器保证订单对象的完整性
    public Order(String orderId, List<OrderItem> items) {
        this.orderId = orderId;
        this.items = new ArrayList<>(items);
        this.createTime = LocalDateTime.now();
        this.totalAmount = calculateTotal();
    }
    
    private double calculateTotal() {
        return items.stream()
                   .mapToDouble(item -> item.getPrice() * item.getQuantity())
                   .sum();
    }
}
```







































