简要讲解Java中方法的重写，并举例实际开发中几个常见的场景

### 一、Java 方法重写（Override）核心概念

方法重写是面向对象多态特性的核心体现，**子类重新定义父类中已存在的非私有、非静态、非 final 方法**，保持方法签名（方法名、参数列表、参数类型 / 顺序）完全一致，仅修改方法实现逻辑。

#### 核心规则（两同两小一大）：

两同	方法名相同、参数列表（个数 / 类型 / 顺序）相同

两小	子类返回值类型 ≤ 父类（如父类返回 Object，子类可返回 String）；子类抛出异常 ≤ 父类（范围更小 / 更少）

一大	子类访问权限 ≥ 父类（如父类是 protected，子类可改为 public，不可改为 private）

#### 关键注意点：

- `static`方法不能重写（属于类，而非对象，子类同名方法仅为 “隐藏”）；
- `private`方法不能重写（父类私有方法子类不可见）；
- 可通过`@Override`注解校验重写合法性（编译期检查，避免写错签名）。

### 二、实际开发中常见场景

#### 场景 1：业务逻辑的差异化实现（如支付方式适配）

**场景描述**：父类定义通用业务接口，子类根据不同业务场景重写核心方法，是最典型的重写场景。例如电商系统中，父类定义 “计算订单金额” 方法，子类（普通订单、秒杀订单、团购订单）重写该方法实现不同的金额计算规则。

```Java
// 父类：订单基类
public class Order {
    protected BigDecimal amount; // 原始金额

    // 计算最终支付金额（父类默认实现：原价）
    public BigDecimal calculatePayAmount() {
        return amount;
    }
}

// 子类1：秒杀订单（重写计算逻辑，打8折）
public class SeckillOrder extends Order {
    @Override
    public BigDecimal calculatePayAmount() {
        return amount.multiply(new BigDecimal("0.8"));
    }
}

// 子类2：团购订单（重写计算逻辑，满100减20）
public class GroupBuyOrder extends Order {
    @Override
    public BigDecimal calculatePayAmount() {
        if (amount.compareTo(new BigDecimal("100")) >= 0) {
            return amount.subtract(new BigDecimal("20"));
        }
        return amount;
    }
}

// 调用示例
public static void main(String[] args) {
    Order normalOrder = new Order();
    normalOrder.amount = new BigDecimal("200");
    System.out.println("普通订单金额：" + normalOrder.calculatePayAmount()); // 200

    Order seckillOrder = new SeckillOrder();
    seckillOrder.amount = new BigDecimal("200");
    System.out.println("秒杀订单金额：" + seckillOrder.calculatePayAmount()); // 160

    Order groupOrder = new GroupBuyOrder();
    groupOrder.amount = new BigDecimal("200");
    System.out.println("团购订单金额：" + groupOrder.calculatePayAmount()); // 180
}
```

**核心价值**：父类定义统一接口，子类按需重写，调用方无需关注具体子类类型，通过多态实现逻辑复用与差异化扩展。

#### 场景 2：框架组件的自定义扩展（如 Spring Boot 的配置类）

**场景描述**：框架提供的父类 / 接口定义了默认行为，开发者通过重写方法自定义框架逻辑。例如 Spring Boot 中，继承`WebMvcConfigurerAdapter`（或实现`WebMvcConfigurer`）重写`addInterceptors`、`addResourceHandlers`等方法，自定义 MVC 配置。

```Java
@Configuration
public class CustomWebMvcConfig extends WebMvcConfigurerAdapter {
    // 重写：添加自定义拦截器
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())
                .addPathPatterns("/**")
                .excludePathPatterns("/login", "/register");
    }

    // 重写：配置静态资源映射
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 自定义静态资源路径，覆盖默认配置
        registry.addResourceHandler("/static/**")
                .addResourceLocations("classpath:/my-static/");
    }
}
```

**核心价值**：基于框架的默认实现，仅重写需要自定义的逻辑，无需重复编写全部代码，符合 “开闭原则”。

#### 场景 3：工具类 / 基础类的行为定制（如 toString () 重写）

**场景描述**：Java 默认的`Object`类提供了`toString()`、`equals()`、`hashCode()`等方法，但默认实现（如`toString()`返回 “类名 @哈希值”）无法满足业务需求，子类需重写这些方法。

```Java
public class User {
    private Long id;
    private String username;
    private Integer age;

    // 重写toString()：返回可读的业务属性
    @Override
    public String toString() {
        return "User{id=" + id + ", username='" + username + "', age=" + age + "}";
    }

    // 重写equals()：按业务主键（id）判断相等
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        return Objects.equals(id, user.id);
    }

    // 重写hashCode()：与equals()保持一致（基于id）
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }

    // getter/setter省略
}

// 调用示例
public static void main(String[] args) {
    User user = new User();
    user.setId(1L);
    user.setUsername("张三");
    user.setAge(20);
    System.out.println(user); // 输出：User{id=1, username='张三', age=20}

    User user2 = new User();
    user2.setId(1L);
    System.out.println(user.equals(user2)); // 输出：true
}
```

**核心价值**：让基础方法适配业务场景，例如`toString()`便于日志打印 / 调试，`equals()`/`hashCode()`保证集合（如 HashMap、HashSet）中对象的正确比较。

#### 场景 4：异常信息的定制化（如自定义异常的 getMessage ()）

**场景描述**：自定义异常时，重写父类的`getMessage()`方法，封装更详细的异常信息（如异常码、业务描述），便于问题定位。

```Java
// 父类：通用业务异常
public class BusinessException extends RuntimeException {
    private int code; // 异常码
    private String detailMsg; // 详细信息

    public BusinessException(int code, String msg, String detailMsg) {
        super(msg);
        this.code = code;
        this.detailMsg = detailMsg;
    }

    // 重写getMessage()：拼接异常码和详细信息
    @Override
    public String getMessage() {
        return "[" + code + "] " + super.getMessage() + "（详情：" + detailMsg + "）";
    }
}

// 调用示例
public static void main(String[] args) {
    try {
        throw new BusinessException(1001, "用户不存在", "用户ID=123未在数据库中找到");
    } catch (BusinessException e) {
        System.out.println(e.getMessage()); 
        // 输出：[1001] 用户不存在（详情：用户ID=123未在数据库中找到）
    }
}
```

**核心价值**：扩展异常信息维度，让异常日志更具可读性，便于开发 / 运维人员快速定位问题。

### 重写使用注意事项

1. 仅重写需要差异化的逻辑，避免完全覆盖父类有用的逻辑；
2. 父类方法若为`final`/`static`，子类无法重写（static 方法同名仅为 “隐藏”）；
3. 重写时尽量保持返回值、异常的兼容性（遵循 “两小一大”），避免破坏多态逻辑；
4. 优先使用`@Override`注解，编译期发现签名错误（如参数写错、方法名拼错）。

综上，方法重写的核心价值是**在保持接口一致的前提下，实现子类的差异化逻辑**，是多态、框架扩展、业务定制的基础，也是实际开发中最常用的面向对象技巧之一。



























