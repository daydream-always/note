简要介绍final关键字

简要介绍static关键字

简要讲解Java继承，并举例实际开发中几个常见的场景

### 一、Java 继承核心概念

继承是 Java 面向对象三大特性（封装、继承、多态）之一，

**允许一个类（子类 / 派生类）继承另一个类（父类 / 基类 / 超类）的属性和方法**，

实现代码复用，同时子类可扩展或重写父类功能。

#### 核心规则：

1. **关键字**：`extends`，Java 是单继承（一个子类只能直接继承一个父类），但可通过接口实现多继承效果；
2. **访问权限**：子类能继承父类的`public`、`protected`成员（属性 / 方法），不能继承`private`成员（但可通过父类的`public/protected`方法间接访问）；
3. **构造方法**：子类构造方法默认调用父类无参构造（`super()`），若父类无无参构造，子类需显式调用父类有参构造；
4. **重写（Override）**：子类可重写父类非`final`、非`static`方法，遵循 “两同两小一大”（方法名 / 参数列表同，返回值 / 异常更小，访问权限更大）；
5. **super 关键字**：子类中用于访问父类的属性、方法、构造方法。

### 二、实际开发中常见场景

#### 场景 1：通用基类封装公共逻辑（如业务实体基类）

**场景描述**：系统中所有业务实体（用户、订单、商品）都有通用属性（创建时间、更新时间、主键 ID）和通用方法（主键校验、时间格式化），可封装为父类，子类继承后只需关注自身特有属性 / 方法。

```java
// 父类：通用业务实体基类
public class BaseEntity {
    private Long id;
    private Date createTime;
    private Date updateTime;

    // 公共方法：主键校验
    public boolean validateId() {
        return id != null && id > 0;
    }
    // getter/setter 省略
}

// 子类：用户实体（继承基类）
public class User extends BaseEntity {
    private String username;
    private String password;

    // 特有方法：密码加密
    public void encryptPassword() {
        this.password = MD5Util.encrypt(this.password); // 假设MD5Util是工具类
    }
}

// 子类：订单实体（继承基类）
public class Order extends BaseEntity {
    private Long userId;
    private BigDecimal amount;

    // 特有方法：订单金额校验
    public boolean validateAmount() {
        return amount != null && amount.compareTo(BigDecimal.ZERO) > 0;
    }
}
```

**核心价值**：避免每个实体类重复编写 ID、时间属性和校验逻辑，统一维护公共逻辑（如后续新增 “删除标记”，只需在 BaseEntity 中添加）。

#### 场景 2：抽象父类定义规范（如业务处理器）

**场景描述**：系统中有多种支付方式（支付宝、微信、银行卡），每种支付的核心流程（创建订单、发起支付、回调处理）一致，但具体实现不同，可定义抽象父类规范流程，子类实现具体逻辑。

```Java
// 抽象父类：支付处理器
public abstract class AbstractPayHandler {
    // 模板方法：定义支付核心流程（固定流程，不可重写）
    public final void pay() {
        createOrder();
        doPay(); // 抽象方法，子类实现
        callback();
    }

    // 公共方法：创建订单（所有支付方式通用）
    private void createOrder() {
        System.out.println("创建统一订单记录");
    }

    // 抽象方法：具体支付逻辑（子类实现）
    protected abstract void doPay();

    // 公共方法：支付回调（通用逻辑）
    private void callback() {
        System.out.println("统一回调结果处理");
    }
}
// 子类：支付宝支付
public class AliPayHandler extends AbstractPayHandler {
    @Override
    protected void doPay() {
        System.out.println("调用支付宝SDK发起支付");
    }
}
// 子类：微信支付
public class WxPayHandler extends AbstractPayHandler {
    @Override
    protected void doPay() {
        System.out.println("调用微信支付SDK发起支付");
    }
} 
```

**核心价值**：通过 “模板方法模式” 固定核心流程，子类仅需实现差异化逻辑，保证业务流程统一，降低维护成本。

#### 场景 3：框架扩展（如 Spring 的 HandlerInterceptor）

**场景描述**：Spring MVC 中自定义拦截器时，需实现`HandlerInterceptor`接口（包含 3 个方法：preHandle、postHandle、afterCompletion），但多数场景只需重写 1-2 个方法，此时可继承框架提供的`HandlerInterceptorAdapter`（适配器类，空实现所有方法），仅重写需要的方法。

```Java
// 框架提供的适配器父类（简化版）
public abstract class HandlerInterceptorAdapter implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        return true; // 空实现
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        // 空实现
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        // 空实现
    }
}

// 自定义拦截器：仅重写preHandle
public class LoginInterceptor extends HandlerInterceptorAdapter {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 校验用户是否登录
        Object user = request.getSession().getAttribute("user");
        if (user == null) {
            response.sendRedirect("/login");
            return false;
        }
        return true;
    }
}
```

**核心价值**：适配器模式的典型应用，父类空实现所有接口方法，子类无需实现无关方法，简化代码编写。

#### 场景 4：异常体系设计

**场景描述**：系统自定义异常时，通常继承`RuntimeException`（或`Exception`），封装统一的异常码、异常信息，子类区分不同业务异常（如用户异常、订单异常）。

```Java
// 父类：通用业务异常
public class BusinessException extends RuntimeException {
    private int code; // 异常码
    private String msg; // 异常信息

    public BusinessException(int code, String msg) {
        super(msg);
        this.code = code;
        this.msg = msg;
    }

    // getter/setter 省略
}

// 子类：用户相关异常
public class UserException extends BusinessException {
    // 预设常见用户异常码
    public static final int USER_NOT_FOUND = 1001;
    public static final int USER_NAME_DUPLICATE = 1002;

    public UserException(int code, String msg) {
        super(code, msg);
    }
}

// 子类：订单相关异常
public class OrderException extends BusinessException {
    public static final int ORDER_NOT_FOUND = 2001;
    public static final int ORDER_STATUS_ERROR = 2002;

    public OrderException(int code, String msg) {
        super(code, msg);
    }
}

// 使用场景
public void getUser(Long userId) {
    User user = userDao.selectById(userId);
    if (user == null) {
        throw new UserException(UserException.USER_NOT_FOUND, "用户ID：" + userId + "不存在");
    }
}
```

**核心价值**：统一异常处理逻辑（如全局异常处理器只需捕获 BusinessException），子类区分业务场景，便于异常定位和分类处理。

### 三、继承使用注意事项

1. **避免过度继承**：继承层级过深（如超过 3 层）会导致代码可读性差，优先用组合（has-a）替代继承（is-a）；
2. **父类设计需谨慎**：父类的修改会影响所有子类，建议父类方法尽量用`final`修饰（除非需要重写），或设计为抽象类 / 接口；
3. **遵循里氏替换原则**：子类必须能替换父类且不影响程序逻辑（如父类返回 List，子类不能返回 null）。

综上，继承的核心价值是**代码复用 + 规范扩展**，实际开发中主要用于封装公共逻辑、定义模板流程、简化框架扩展、构建统一体系（如异常、实体）。































