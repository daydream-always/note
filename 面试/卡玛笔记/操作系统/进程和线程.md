# 进程和线程

## 进程和线程的区别是什么？

### 基本概念

- **进程（Process）** 是操作系统进行**资源分配的最小单位**。每个进程拥有独立的虚拟地址空间，以及独立的系统资源（如文件描述符、信号处理方式等）。
- **线程（Thread）** 是操作系统进行**CPU 调度和程序执行的最小单位**。线程本身不拥有独立的系统资源，而是依附于进程存在。
- 一个进程可以包含多个线程，多个线程**共享同一进程的地址空间和资源**（代码段、数据段、堆、打开的文件等），但**每个线程拥有独立的栈和寄存器上下文**。

### 区别

1. **资源开销**
   1. 进程拥有独立的内存空间，创建和销毁进程的开销较大。进程上下文切换需要保存和恢复完整的进程状态（如页表、寄存器等），切换开销较大。
   2. 线程共享进程的内存空间，创建和销毁开销较小。线程上下文切换只需保存和恢复少量寄存器和栈信息，切换开销较小。
2. **通信与同步**
   1. 进程之间相互隔离，通信需要借助操作系统提供的机制，如管道、消息队列、共享内存、信号、Socket 等。
   2. 线程共享相同的内存空间，可以直接访问共享数据，但需要通过互斥锁、条件变量等同步机制保证数据一致性。
3. **安全性**
   1. 进程之间相互隔离，一个进程的崩溃通常不会直接影响其他进程。
   2. 线程之间共享内存空间，一个线程发生非法访问，可能导致整个进程崩溃。

## 并行和并发有什么区别？

- **并行（Parallelism）** 并行是**同一时刻**执行多个任务。通常依赖多核 CPU 或多个处理单元，多个任务真正同时运行。
- **并发（Concurrency）** 并发是在**同一时间段内**处理多个任务。对于单核 CPU，通过时间片轮转机制，让多个任务交替执行，在宏观上表现为同时进行。

## 解释一下用户态和核心态？

#### 简要回答

- **用户态**：用户态是CPU**运行用户程序**的一种模式，权限较低，**不能直接访问硬件资源**；用户态需要通过系统调用（System Call）请求内核态的服务。
- **内核态**：内核态是CPU**运行操作系统内核**的一种模式，拥有最高权限，**可以直接访问硬件资源**；内核态负责管理系统的核心功能，如进程调度、内存管理、设备驱动等。

------

#### 详细回答

- **用户态**：当在用户空间执行应用程序自己的代码时，称为**用户模式（User Mode）**，也称为用户态；当CPU处于用户态时**只能运行部分指令，访问特定范围的内存空间，即用户空间**，而应用程序的代码和数据保存在用户空间中。
- **内核态**：用户程序调用系统API函数称为**系统调用**，一旦发生了系统调用，将暂停用户程序的执行，转而执行内核代码，访问内核空间，这称为**内核模式（Kernel Mode）**，也称为内核态；处于内核态时**可以运行全部指令，访问全部内存空间**，具有对硬件的完全访问权限。
- 通常，内核态不直接运行用户程序（即便内核态可以访问用户空间），而是通过系统调用机制安全地与用户空间交互。具体来说，当用户程序需要执行某些特权操作时，它会通过 **系统调用（System Call）** 请求操作系统的服务。系统调用会触发从用户态到内核态的切换，此时CPU会执行操作系统提供的服务代码来完成用户请求的操作，执行完成后再转换为用户态继续执行用户程序。这种设计确保了系统的安全性与稳定性，同时实现了用户程序与内核的隔离。

------

#### 知识拓展

- 计算机系统分层结构如下图所示：

  ![image.png](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/678388eee1dc4-phpoba7bZ.png)

- 由上图可知，操作系统是最基本的系统软件，是计算机系统各类软硬件资源的管理者；它位于用户层和硬件层之间，**向上提供服务、向下管理资源**。

- 进程间的切换无法直接通过硬件实现，因此还需要一层系统软件来对处理器和硬件资源进行抽象改造，这一层系统软件即为操作系统内核，内核是一组运行在内核态的程序模块。

- CPU中有一个寄存器叫＂程序状态字寄存器（PSW）＂，其中有个二进制位，可用1表示”内核态"，0表示"用户态"，亦可反之。

## 进程调度算法你了解多少？

![img](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/_caozuoxitongtiaodusuanfa_dalaodaidaiwo.png)

进程调度算法是操作系统用来决定在多道程序设计环境中，哪些进程应当获得 CPU 的使用权的一种策略。选择合适的调度算法对于优化系统性能、提高响应速度、减少等待时间等方面至关重要。常见的进程调度算法有很多种，每种算法都有其特点、优劣势以及适用场景。

### 1. **先来先服务（FCFS, First-Come, First-Served）**

**定义**：

- **FCFS** 是最简单的一种调度算法，它根据进程到达的顺序进行调度。即第一个到达的进程先执行，后到达的进程后执行。

**特点**：

- 非抢占式，即一旦进程开始执行，它将一直执行，直到完成。
- 调度简单，容易实现。
- **问题**：容易导致“饥饿”现象或**长任务阻塞短任务**，也容易引起 **队列效应**，即进程等待时间较长，导致 **平均等待时间** 高。

**适用场景**：

- 适用于进程执行时间较为均匀、没有突发较长进程的情况，或者任务间的执行时间差距较小的系统。

### 2. **短作业优先（SJF, Shortest Job First）**

**定义**：

- **SJF** 是一种非抢占式的调度算法，优先选择执行运行时间最短的进程。通过预测每个进程的执行时间来确定调度顺序。

**特点**：

- 如果执行时间已知，能够使 **平均等待时间最小**，即优化了系统的响应时间。
- 该算法会导致 **长进程饥饿**，如果总是有新的短进程到来，长进程就可能一直无法执行。
- 在实际情况中，预测每个进程的执行时间通常很困难。

**适用场景**：

- 对于已知作业长度、进程执行时间比较稳定的系统，或者执行任务相对较短的场景，SJF 可以发挥较好性能。

### 3. **最短剩余时间优先（SRTF, Shortest Remaining Time First）**

**定义**：

- **SRTF** 是抢占式的 **SJF** 算法，它选择剩余执行时间最短的进程。若一个新进程到来时其剩余时间比当前正在执行的进程短，则会抢占 CPU 执行。

**特点**：

- 与 SJF 相似，但具有抢占式特性。
- 可以有效地减少平均等待时间。
- 与 SJF 一样，可能导致 **长进程饥饿**，并且对于未知的执行时间预测存在挑战。

**适用场景**：

- 适用于已知剩余执行时间，且优先调度短任务的系统。

### 4. **优先级调度（Priority Scheduling）**

**定义**：

- 进程根据优先级进行调度。优先级高的进程先执行，优先级低的进程后执行。
- 优先级可以根据不同的标准设定，例如任务的重要性、所需资源等。

**特点**：

- 可实现抢占式或非抢占式调度。抢占式优先级调度在运行过程中，若一个新进程的优先级高于当前执行进程，则会抢占 CPU。
- 可能导致 **低优先级进程饥饿**，特别是在长时间不调整优先级的情况下。
- 动态优先级调度可以通过 ** aging 算法**（逐渐提高低优先级进程的优先级）来解决饥饿问题。

**适用场景**：

- 适用于多种任务重要性不同的场景，例如一些实时性较强的任务需要优先执行，而其他任务则可以稍后处理。

### 5. **轮转法（RR, Round Robin）**

**定义**：

- **RR** 是一种时间片轮转的调度算法。每个进程分配一个固定的时间片，当进程的时间片用尽后，它会被放回队列的末尾，等待下一次轮到它继续执行。

**特点**：

- 抢占式算法，每个进程的执行时间受到限制（即时间片的长度）。
- 适合 **响应时间要求较高** 的系统，能保证各个进程公平地获得 CPU 资源。
- 但如果时间片设置不合理（过短或过长），可能会导致 **过多的上下文切换**，从而增加开销。

**适用场景**：

- 适用于交互式系统（如操作系统的命令行和图形界面），或者对响应时间有较高要求的系统，如时间共享系统。

### 6. **多级反馈队列调度（Multilevel Feedback Queue）**

**定义**：

- MLFQ是一种结合多级队列与优先级调度的策略。在 MLFQ 中，当新进程到达时，它会被放入最高优先级的队列中。每个队列都对应一个时间片，进程会按队列中的时间片运行。当进程用完当前队列的时间片时：
  - 如果它还未完成，则会被移到下一个低优先级队列中，进入新的队列后，它的执行时间片通常会变长。
  - 如果进程在时间片内完成任务，它将从队列中移除。

**特点**：

- 结合了 **FCFS**、**SJF** 和 **优先级调度** 的优点，可以有效避免饥饿问题，同时尽量减少长任务的等待时间。
- 动态调整进程的优先级，使得短任务能够更快执行，长任务能逐步降级。
- 算法设计复杂，涉及多个队列和多次调度策略。

**适用场景**：

- 多任务系统或负载较重的系统，可以根据实际负载自动调整调度策略，保证较好的响应性和公平性。

### 总结与选择：

不同的调度算法适用于不同的应用场景，选择适合的调度算法需要根据具体需求来决定：

- 对于 **实时系统**，需要保证任务按时完成，常用的调度算法包括 **优先级调度** 和 **最短作业优先**。
- 对于 **交互式系统**，如多任务桌面操作系统，常用 **轮转法** 和 **多级反馈队列调度**。
- 对于需要 **平衡效率和公平性** 的情况， **多级反馈队列** 是一种比较理想的选择。

## 进程间有哪些通信方式？

1. **管道（Pipe）**
   - 内核中的缓冲区
   - 半双工通信
   - 匿名管道用于父子进程
   - 命名管道（FIFO）可用于无关进程
2. **消息队列**
   - 内核中的消息链表
   - 消息大小有限
   - 存在用户态和内核态之间的数据拷贝开销
3. **共享内存**
   - 多个进程映射到同一块物理内存
   - 通信效率最高
   - 需要配合同步机制使用
4. **信号量（Semaphore）**
   - 整型计数器
   - 用于进程间同步和互斥
   - 不用于数据传输
5. **信号（Signal）**
   - 操作系统提供的异步通知机制
   - 常用于异常处理和进程控制
6. **Socket**
   - 支持同一主机或跨网络进程通信

## 什么是孤儿进程和僵尸进程，如何处理它们？

#### 孤儿进程

一个进程的父进程意外终止，而它仍然运行；操作系统会自动接管孤儿进程，使其成为init的子进程，它的退出状态由init负责

#### 僵尸进程

当子进程终止，但其父进程并没有调用获取子进程的退出状态时，子进程的进程表仍然留在系统中；也就是说：一个进程终止，但是并未被清除。僵尸进程会占用系统有限表项，所以要避免僵尸进程的堆积

##### 处理方法

调用wait或 waitpid，对子进程的退出状态回收

## 进程有几种状态，它们之间是如何转换的？

通常，进程的主要状态包括**新建**、**就绪**、**运行**、**阻塞**（等待）、**结束**，以及一些其他细化的状态。

#### 2. **就绪 → 运行**

- 当调度程序选择一个就绪进程，并为其分配 CPU 时，进程从就绪状态转变为运行状态。
- 例如，当时间片轮到某个就绪进程，操作系统的调度器将 CPU 分配给它。

#### 3. **运行 → 就绪**

- 当正在运行的进程因为时间片耗尽或者被抢占而暂停执行时，会返回到就绪状态。
- 例如，在多任务环境下，如果有更高优先级的进程需要运行，正在运行的进程会被抢占并切换到就绪状态。

#### 4. **运行 → 阻塞**

- 当进程需要等待某个事件时，例如等待 I/O 完成、等待资源、等待信号等，会从运行状态转变为阻塞状态。
- 例如，进程请求一个文件的 I/O 操作时，由于 I/O 操作比较慢，需要等待完成，进程会从运行状态进入阻塞状态。

#### 5. **阻塞 → 就绪**

- 当阻塞的事件完成时，例如 I/O 操作结束、等待的资源可用等，阻塞进程会重新进入就绪状态。
- 例如，某进程在等待 I/O 操作，当操作完成后，该进程被唤醒，进入就绪状态。

## 什么是作业调度和进程调度，它们之间有什么区别？

### 1. 作业调度（Job Scheduling）

- **定义**： 作业调度是操作系统中的一种调度机制，用于将提交给系统的一组作业按照一定的策略加载到内存中并转化为进程，从而为后续的执行做准备。

### 2. 进程调度（Process Scheduling）

- **定义**： 进程调度是操作系统中的一种调度机制，用于决定处于内存中的多个就绪进程中哪个进程获得 CPU 的使用权。

### 它们的关系

1. 交互关系：

   - 作业调度决定哪些作业进入内存并变为进程，进程调度则管理这些进程的执行顺序。
   - 作业调度是进程调度的前提：只有被作业调度调入内存的作业才能参与进程调度。

2. 资源分配层级：

   - 作业调度关注系统的整体资源分配策略，避免资源过载或浪费。
   - 进程调度聚焦于 CPU 的分配与切换，确保 CPU 高效运行。

3. 系统运行效率

   ：

   - 作业调度通过控制多道程序数，平衡 CPU 密集型和 I/O 密集型作业，从宏观上提高系统资源的利用率。
   - 进程调度通过合理分配 CPU 时间，提高系统的响应速度和用户体验。

## 解释一下操作系统的信号机制，以及它的作用？

**简要回答**

**信号机制**是操作系统提供的一种进程间通信和事件通知机制，用于向进程传递异步事件。信号可以由操作系统或其他进程发送，并由目标进程处理。其主要作用是：

1. **通知事件**：如进程中断、定时器到期或硬件异常。
2. **进程控制**：如终止、暂停、继续或重启进程。
3. **进程间通信**：让一个进程向另一个进程发送特定的通知或指令。

## 解释一下操作系统的中断机制，以及它的作用？

##### 异常和中断的基本概念

- 当一条指令执行结束时，需要进行内部异常和外部中断请求的判断。如果存在异常或中断请求，需要进入异常或中断响应过程，主要任务是**保存断点和程序状态**，**识别异常事件或中断源**，并**进入相应的服务程序**进行处理。
- 异常和中断机制是**操作系统获得CPU控制权的唯一方式**，当中断或者异常事件发生时，CPU切换至**内核态**，操作系统得以获得所有特权指令的权限，通过执行操作系统提供的 异常或中断处理程序 来处理异常或中断事件。
- **异常**：是指CPU执行一条指令时，由CPU在其**内部**检测到的、与正在执行的指令相关的**同步事件**。
- **中断**：是指一种典型的由**外部**设备触发的、与当前正在执行的指令无关的**异步事件**。

##### 异常和中断的分类

1. 内部异常（Exception）：
   - 也被称为**内部中断** 或者 **软件中断**，异常是CPU执行当前指令产生的事件，是同步发生的，与CPU正在执行的指令密切相关。
   - 异常事件可进一步划分为**故障（Fault）**，**自陷（Trap）**，**终止（Abort）**。
2. 外部中断（Interrupt）：
   - **外部中断来自CPU外部，与具体的指令无关，是随机事件**，中断是指外部设备向CPU发出的中断请求（如鼠标点击、键盘按键等），中断提供了外设与CPU交流的机制，它也是一种重要的**I/O方式**。CPU会在当前指令执行完毕后响应中断请求，进而转移到对应的中断处理程序，处理完毕后返回到发生中断的那条指令的下一条指令（因为被中断指令已经执行完毕）。
   - 按中断请求是否可被屏蔽分类，可分为**可屏蔽中断** 和 **非屏蔽中断**。
   - 按中断事件能否直接提供中断服务地址分类，可分为**向量中断** 和 **非向量中断**。
   - 按中断处理过程能否被打断分类，可分为**单重中断** 和 **多重中断**。

##### 异常和中断的处理

- 异常与中断的处理方式基本一致，当发生中断事件时，CPU接收到中断请求，在当前指令结束时CPU进入**中断周期**进行中断响应，并在**中断响应**中引入中断服务程序，由中断服务程序执行后续的**中断处理**。当然也有例外，例如产生故障异常的指令并没有执行完毕，但必须立即进行中断响应。



评论(3)

KamaCoder106502

1/5/26, 8:56 PM

进程与线程的区别是什么，也就是第一个标题下的那个： 资源开销： 每个进程有独立的内存空间，创建和销毁进程的开销较大。（协程）间切换需要保存和恢复整个进程的状态，进程上下文之间切换的开销也比较大。 多个线程共享一块内存空间，创建和销毁的开销比较小。线程直接切换只需要保存少量（协程）上下文，因此上下文的切换开销较小。 以上这段话中的协程是不是错的，第一个应该改成进程，第二个应该改成线程吧，协程不是在线程之下的一个并发单位吗，优势相对于线程来说好像是不用切换成内核态

卡码网官方账号

1/14/26, 7:04 PM

已经修改🌹



KamaCoder200096

1/7/26, 3:41 AM

老哥虽然很感谢你制作了这么丰富的笔记，但是咱最好还是拿ChatGPT过一遍筛选掉明显错误再拿出来……我也是注意到106502老哥说的错误，然后把这一页丢给GPT，少说有20处错误……

KamaCoder200096

1/7/26, 3:48 AM

信号量是进程间通信方式……nb



卡码网官方账号

1/14/26, 7:05 PM

对本篇已经全面修改，如果还有问题，欢迎反馈🌹

