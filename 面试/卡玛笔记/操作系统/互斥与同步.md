# 互斥与同步

## 什么是银行家算法，它是如何解决死锁问题的？

#### 简要回答

1. 银行家算法的概念：
   - **银行家算法**是一种用于**动态资源分配**的死锁避免算法，由荷兰科学家 **Dijkstra** 提出。其核心思想是：**对于每次资源申请，系统都要实时判断其是否有死锁风险，如果存在风险，就拒绝该申请；仅在资源分配后系统仍处于安全状态时，才允许分配资源**，从而**避免死锁**。
2. 银行家算法的实现：
   - **安全状态检查**：每次分配资源前，模拟分配后的系统状态，判断系统是否存在一个 **安全序列**（所有进程能按顺序获得所需资源并完成）。
   - **动态决策**：若安全状态成立，则正式分配资源；若无法找到安全序列，则拒绝资源请求，防止系统进入可能导致死锁的状态。

------

#### 详细回答

1. 银行家算法的概念：

   - **银行家算法**是一种用于**动态资源分配**的死锁避免算法，由荷兰科学家 **Dijkstra** 提出。其核心思想是：**对于每次资源申请，系统都要实时判断其是否有死锁风险，如果存在风险，就拒绝该申请；仅在资源分配后系统仍处于安全状态时，才允许分配资源**，从而**避免死锁**。

2. 银行家算法的实现：

   - 每次有新进程进入系统时，进程必须提前声明运行周期中可能需要的每一类资源的最大单位数目，该单位数目不得超过系统拥有的资源总数。
   - 当一个进程实际请求一组资源时，银行家算法会对请求进行检查，系统必须首先确定是否有足够的资源可以分配给该进程。
   - 如果当前系统资源充足，它就会计算将这些资源分配给该进程是否会使系统进入不安全状态。如果该分配安全，则将资源分配给该进程；否则，暂时不批准这一资源请求。

3. 银行家算法的数据结构：

   - 系统可用资源向量`Available[m]`：表示系统中每种资源的可用数量，随着系统资源分配与回收情况的变动而动态变化。
   - 最大需求矩阵`Max[n][m]`：表示系统中 n 个进程中每个进程对 m 类资源的最大需求量。
   - 分配矩阵`Allocation[n][m]`：表示当前每个进程占有的各类资源数量。
   - 需求矩阵`Need[n][m]`：表示进程完成任务还需要每种资源的数量；`Need[i][j] = Max[i][j] - Allocation[i][j]`。

4. 银行家算法的思想：

   - 设Request i 为进程 Pi 的请求向量，当 Pi 申请一个资源时，系统进行以下检查：
     ① 如果 `Request i <= Need[i][j]`，则进入步骤 ②；否则说明进程所需要的资源数量已经超过了它所申报的最大需求数量，请求失败。
     ② 如果 `Request i <= Available[j]`，则进入步骤 ③；否则说明系统还没有足够的空闲资源，进程 Pi 必须等待。
     ③ 系统试图为进程 Pi 分配资源，并更新以下数据结构中的值：

     ```
     Available[j] = Abailable[j] - Request i [j];
     Allocation[i][j] = Allocation[i][j] + Request i [j];
     Need[i][j] = Need[i][j] - Request i [j];
     ```

     ④ 系统通过**安全性算法**检查为该进程分配资源后，是否仍处于安全状态。如果系统是安全的，资源就被正式分配给进程 Pi；否则，终止分配，系统回退到原来的资源分配状态，并让进程 Pi 继续等待。

5. 银行家算法的安全性检查：

   - ① 定义两个向量：**工作向量Work[m]** 表示系统中可用于维持进程运行的各类资源的数量，在安全性算法执行前，令 Work = Available；**Finish[n]** 表示系统中是否有足够的资源分配给该进程，以使其运行完毕，初始化 **Finish[i] = FALSE**，当有足够的空闲资源分配给进程 Pi 时，令**Finish[i] = TRUE**。

   - ② 在进程集合中找到一个进程，使其满足条件——`Finish[i] == FALSE && Need[i][j] ≤ Work[j]`，如果能找到，则执行步骤 ③，否则执行步骤 ④。

   - ③ 若进程满足步骤 ② 中的条件，说明当进程 Pi 被分配资源后，它可以顺利运行完毕，并释放其占有的资源，以供其他进程使用，这时应该执行如下指令：

     ```
     Work[j] = Work[j] + Allocation[i][j];
     Finish[i] = TRUE;
     继续进行步骤 ② (循环执行步骤2，直到所有进程都满足 Finish[i] == TRUE，或者其中一个进程不满足步骤2中的判断条件);  
     ```

   - ④ 如果 **Finish[i] == TRUE** 对于进程集合中的每个进程都满足，说明系统处于安全状态，允许此次资源分配；否则，系统处于不安全状态。

------

#### 知识拓展

##### 三图胜三千言

- 银行家算法的核心思想，如下图所示：

  ![banker_algorithm_one.jpg](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/f829ccde-b0e7-4dd1-bf84-6e4a158f1f67.jpg)

- 银行家算法的安全性检查算法，如下图所示：

  ![banker_algorithm_two.jpg](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/6211f02d-4fae-4974-a99e-eac66a0db46e.jpg)

- 银行家算法的整体执行流程，如下图所示：

  ![banker_algorithm_three.jpg](http://cdn.notes.kamacoder.com/e181bdc0-4810-4203-aee5-b6a28ec900bd.jpg)

##### 银行家算法的优缺点

1. 优点：
   - 严格避免死锁，保证系统安全。
   - 资源利用率高于死锁预防策略（如一次性分配）。
2. 缺点：
   - **静态需求假设**：进程需预先声明最大资源需求，现实中难以动态调整。
   - **计算开销大**：每次请求需遍历所有进程，时间复杂度为 O(n²)。
   - **不适用于不可抢占资源**：如打印机、独占设备。

## 解释一下进程同步和互斥，以及如何实现进程同步和互斥？

在操作系统中，**进程同步（Synchronization）**和**进程互斥（Mutual Exclusion）**是保证多个进程或线程安全并发执行的两个关键机制。

------

一、进程互斥（Mutual Exclusion）

定义

进程互斥是指**多个进程不能同时进入临界区（访问共享资源）**。目的是避免竞争条件和数据不一致的问题。

临界区（Critical Section）

指访问共享资源（如全局变量、文件、缓冲区）的代码区域。

实现方式

- **锁机制**（Lock/Mutex）：加锁与解锁。
- **信号量（Semaphore）**：P/V 操作。
- **自旋锁（Spinlock）**：忙等待。
- **原子操作**：如 test-and-set、compare-and-swap。

------

二、进程同步（Synchronization）

定义

进程同步是为了**协调多个进程之间的执行顺序**，使它们按一定逻辑合作完成任务。

举例

- 生产者/消费者问题
- 有先后依赖关系的任务执行

实现方式

- **信号量（Semaphore）**
- **条件变量（Condition Variable）**
- **事件机制（Event）**
- **管程（Monitor）**
- **消息队列、共享内存、管道等进程通信机制**

------

三、图示说明

互斥机制示意图

![image](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/2025-07-30_12-20-59.jpg)

只有一个进程能进入临界区，其它进程必须等待。

------

同步机制示意图（生产者/消费者）

```
  ┌──────────┐         ┌─────────────┐
  │ 生产者    ├────────►  放入缓冲区  │
  └──────────┘         └────┬────────┘
                            ▼
                    ┌─────────────┐
                    │ 取出缓冲区  ◄────────┐
                    └─────────────┘        │
                            │           ┌───────┐
                            └──────────►│消费者 │
                                        └───────┘
```

使用信号量控制缓冲区状态，确保不会出现“空取”或“满放”。

------

四、常见实现方式对比

| 实现方式      | 用于互斥 | 用于同步 | 阻塞机制 | 是否忙等 |
| ------------- | -------- | -------- | -------- | -------- |
| mutex         | ✅        | ❌        | 阻塞线程 | ❌        |
| semaphore     | ✅/✅      | ✅        | 阻塞线程 | ❌        |
| spinlock      | ✅        | ❌        | 无       | ✅        |
| condition var | ❌        | ✅        | 阻塞线程 | ❌        |
| 原子指令      | ✅        | ❌        | 无       | ✅        |

------

五、总结

- **互斥关注“资源不能同时访问”**，防止数据竞争。
- **同步关注“操作按顺序发生”**，协调进程执行顺序。
- 通常使用锁、信号量、条件变量等工具实现。

## 什么是死锁，如何预防死锁？

一、什么是死锁？

**死锁（Deadlock）** 是指两个或多个进程在执行过程中，因为争夺资源而造成的一种互相等待的现象，若无外力干预，它们都将无法继续执行。

死锁产生的经典示意图

```
+--------+       +--------+
| Proc A |<----->| Proc B |
+--------+       +--------+
    |                |
  [R1]             [R2]
```

进程 A 占有 R1，等待 R2；进程 B 占有 R2，等待 R1，形成环路，进入死锁。

------

二、产生死锁的四个必要条件（操作系统理论）

1. **互斥条件（Mutual Exclusion）** 每个资源要么已经分配给了一个进程，要么就是可用的（不可同时被两个以上进程使用）。
2. **请求与保持条件（Hold and Wait）** 一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不剥夺条件（No Preemption）** 进程已经获得的资源，在未使用完之前，不能强行剥夺。
4. **循环等待条件（Circular Wait）** 存在一种进程资源的循环等待链，使得每个进程都等待下一个进程所占有的资源。

------

三、如何预防死锁？

1. **破坏必要条件**

- **破坏互斥条件**：不太现实，部分资源本身就是不能共享的（如打印机）。
- **破坏请求与保持**：一次性申请所有资源（代价高，不灵活）。
- **破坏不剥夺条件**：当某一进程请求资源失败时，主动释放已占资源。
- **破坏循环等待**：对所有资源统一编号，进程必须按照编号递增顺序请求资源。

1. **避免死锁（动态检测）**

- 使用银行家算法（Banker's Algorithm）：
  - 在资源分配前模拟是否会导致死锁。
  - 只有在系统处于安全状态下才允许资源分配。

1. **死锁检测与恢复**

- 允许系统进入死锁状态，定期检测是否存在死锁。
- 检测后通过撤销进程、抢占资源等方式进行恢复。

------

四、总结

| 方法       | 优点                   | 缺点                   |
| ---------- | ---------------------- | ---------------------- |
| 预防死锁   | 简单直接，防患于未然   | 通常资源利用率低       |
| 避免死锁   | 动态检测，灵活性好     | 实现复杂，运行开销大   |
| 检测与恢复 | 最大限度提高资源利用率 | 存在死锁风险，处理复杂 |

## 解释一下PV操作，以及它在进程同步中的应用？

#### 简要回答

1. PV操作与信号量机制的关系：
   - **P操作**和**V操作**是信号量的两种**原子操作**，通过增减信号量值实现资源分配与释放，信号量（Semaphore）是一种**同步工具**，通过PV操作（原子增减操作）协调多进程/线程对共享资源的访问。
2. PV操作的原理：
   - **P操作（wait原语 / 等待）**：申请资源，若资源不足则阻塞当前进程。
   - **V操作（signal原语 / 释放）**：释放资源，若有等待进程则唤醒。
3. PV操作在进程同步中的应用
   - **互斥访问（Mutual Exclusion）**：通过二进制信号量保护临界区。
   - **同步协作（Synchronization and Coordination）**：通过计数信号量协调进程执行顺序。
   - **经典问题（Classic Scenarios）**：生产者 - 消费者 问题；哲学家进餐 问题；读者 - 写者 问题。

------

#### 详细回答

##### PV操作与信号量机制的关系

1. PV操作的角色：
   - **P操作**和**V操作**是信号量的两种**原子操作**，通过增减信号量值实现资源分配与释放。
2. 信号量机制：
   - **定义**：信号量（Semaphore）是一种**同步工具**，通过PV操作（原子增减操作）协调多进程/线程对共享资源的访问。在操作系统中，信号量是一种关联一类临界资源的数据结构，信号量的不同值表示一个临界资源的不同状态。
   - **分类**： Δ 从用途和取值范围出发，可分为**二进制信号量** 和 **计数信号量**。 **二进制信号量**（互斥信号量）：值为0或1，通常会有额外的约束机制确保其值只在0和1之间变化，用于互斥访问（如临界区保护） ；**二进制信号量的本质**是其逻辑值只有两个状态（可用/不可用），而不是其内部实现值的范围。 **计数信号量**（同步信号量）：值可正可负，具体取决于其实现机制，用于管理多个同类资源（如缓冲区空槽）；当同步信号量的值大于等于0时，**信号量的绝对值表示可用资源的数量**；当同步信号量的值小于0时，**信号量的值的绝对值就是等待该资源的进程数**。 Δ 从实现机制和行为特性出发，可分为**整型信号量** 和 **记录型信号量**。 **整型信号量**：把信号量定义为一个用于表示资源数目的整数S，对于S的访问（加减）只能通过**原语**实现；可以把整型信号量机制看作是对S定义了**三种操作——①初始化；②减1；③加1**。整型信号量只能取非负整数。 **记录型信号量**：在整型信号量中，如果S ≤ 0时，P操作会陷入“忙等”状态，不满足同步机制设计准则的“**让权等待**”准则。记录型信号量在整型信号量的基础上，增加了一个**被阻塞进程的队列**，用于链接所有等待相应资源的进程，以实现“让权等待”。记录型信号量可正可负。
   - **核心作用**：通过PV操作实现进程间的同步与互斥。

##### PV操作的原理

1. P操作（wait原语 / 等待）：
   - **P原语**，又称**wait原语**，用于实现对S值的**减1**，减1相当于**申请并获取**一个资源，资源不足则开始等待。
2. V操作（signal原语 / 释放）：
   - **V原语**，又称**signal原语**，用于实现对S值的**加1**，加1相当于**使用结束并释放**一个资源，若有进程在等待该资源，则唤醒一个进程。
3. 关键特性：
   - **原子性**：通过 硬件指令 或 禁用中断 保证 P操作和V操作 不可分割。
   - **阻塞与唤醒**：P操作可能阻塞进程，V操作可能唤醒进程。
   - **队列管理**：信号量的等待队列通常遵循 FIFO 或 优先级策略。

##### PV操作在进程同步中的应用

1. 互斥访问（Mutual Exclusion）：
   - **场景**：多个进程需**互斥访问共享资源**（如打印机、共享内存）。
   - **实现**：初始化二进制信号量 mutex = 1；每个进程在访问临界区前需对互斥量mutex执行P操作，在退出临界区后需对互斥量mutex执行V操作。
2. 同步协作（Synchronization and Coordination）：
   - **场景**：多个进程在执行中有**确定的前后关系**，例如进程Pa用于拉取数据，进程Pb用于对数据进行处理，那么Pb就必须在Pa之后执行。
   - **实现**：可以将同步信号量的初始值置为0，只要进程Pa没有对资源执行V操作，那么进程Pb就会始终在P操作中阻塞等待；只有当进程Pa先执行了V操作，进程Pb才能成功执行P操作，继而去处理数据。
3. 经典问题（Classic Scenarios）：
   - **生产者 - 消费者问题**：是对合作进程中内部关系的抽象化，可以描述为一组生产者和一群消费者一起工作，通过一个大小为 n 的**有限缓冲区**进行生产和消费。**一个缓冲区可以容纳 n 个产品**，其中生产者负责投放产品，消费者负责消费产品。
   - **哲学家进餐问题**：是进程同步的一个典型问题，可以描述为有五个哲学家围坐在一起，每两个人中间只有一只筷子，**每根筷子都不相同**，只有当一个哲学家既拿起他左边的筷子又拿起他右边的筷子时，才能吃饭。如果五个哲学家同时拿起他们左边的筷子，就会出现循环等待的情况，导致死锁发生。
   - **读者 - 写者问题**：是对数据对象（数据文件或记录）的访问模型，可以描述为有一个共享文件File，允许几个读者进程同时读取File中的内容，但在任何时刻只允许一个写者进程写入或修改File中的内容。当一个进程正在**读取File中的内容**时，允许其他进程也读取File但不允许其他进程写入或修改File；当一个进程正在**对File进行写入或修改**时，既不允许其他进程读取File也不允许其他进程写入或修改File。

------

#### 知识拓展

1. 一张“读者 - 写者问题”的示意图如下所示：

    

   ![readers_writers_problem.jpg](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/b1c61c75-4acb-492b-9bbd-e2559078ec6b.jpg)

2. 生产者 - 消费者问题的解决方案：

   - **同步准则**： ① 如果缓冲区已满，生产者试图放入产品时应当被阻塞，等待消费者取出产品、缓冲区有空位后再将其唤醒。 ② 如果缓冲区为空，消费者试图拿取产品时应当被阻塞，等待生产者放入产品、缓冲区有资源后再将其唤醒。
   - **参考实现**： ① 设置两个同步信号量：empty表示当前缓冲区中空位的数量，初始值为n，对应缓冲区大小为n；full表示当前缓冲区中已放入资源的数量（即非空位的数量），初始值为0。 ② 设置一个互斥信号量：mutex = 1，实现临界区的互斥访问。

3. 哲学家进餐问题的解决方案：

   - 最对允许四名哲学家同时进餐（破坏了死锁四个必要条件中的“**循环等待**”条件）。
   - 只有在哲学家的左右两边都有筷子的情况下，才允许哲学家进餐（破坏了死锁四个必要条件中的“**请求和保持**”条件）。
   - 让编号为奇数的哲学家先拿左手边的筷子，再拿右手边的筷子，编号为偶数的哲学家的拿取顺序与之相反（破坏了“**循环等待**”条件）。

4. 读者 - 写者问题的解决方案：

   - **读者优先**：读进程具有优先权，其访问临界区时，只要有一个读进程在读，读进程就能继续获得对临界区的控制权，但可能导致写进程饥饿。
   - **写者优先**：写进程具有优先权，如果有写进程希望访问临界区，就会禁止新的读进程进入临界区，解决了写进程饥饿的问题。
   - **读写公平**：不偏袒读者进程或写者进程中的任何一方，仅根据读写请求的到达顺序来赋予读写的权利。

## 介绍一下几种典型的锁？

互斥锁：互斥锁是最常见的一种锁类型，用于实现互斥地访问共享资源。在同一时刻，某一共享资源只能由持有锁的进程进行访问，其他进程只能等待锁的释放。

自旋锁：自旋锁是一种基于忙等待的锁，即进程在尝试获取锁时，会不断的查询锁是否被释放，直到获得锁。

其他的锁都是基于这两种锁：

1、读写锁：允许多个进程同时对共享资源做读资源，但是只有一个进程能对共享资源进行写操作。锁的状态分为读和写两个状态。

2、悲观锁：认为存在多个进程会同时对共享资源进行访问，所以每次都先获取锁，然后再获取资源。

3、乐观锁：认为多进程进行争夺共享资源的情况较少，所以先对共享资源进行修改，若存在同时修改的情况再放弃本次操作。

## 你知道的线程同步的方式有哪些？

线程同步是多线程编程中的一个重要概念，用于确保多个线程在访问共享资源时不会出现数据不一致的问题。同步的目的是协调线程的执行顺序，以避免并发冲突。

常见的线程同步方式有：

- **互斥锁**： 独占访问，一次只允许一个线程持有锁。如果锁已被占有，其他线程尝试获取时会阻塞等待，直到锁被释放。这确保了同一时间只有一个线程能够访问被保护的资源；
- **自旋锁**： 当一个线程尝试获取已被持有的锁时，它会在一个循环中不断尝试，而不是立即阻塞；
- **读写锁**： 分为读操作和写操作，可以同时有多个读线程访问共享内存，但是只能有一个写线程进行对共享内存的写操作；
- **条件变量**： 通常和互斥锁搭配使用，
- 信号量： 信号量本质是一个计数器，用于控制多个程序对共享资源的访问。一般分为两种类型：
  1. **计数信号量**：允许对资源进行多次访问，其计数值表示可用资源的数量。
  2. **二进制信号量（类似于互斥锁）**：只允许一个线程访问资源，用于实现互斥。
- **屏障**： 一种同步机制，保证所有线程都到达某个同步点后，才能继续执行后续代码。

## 什么是管程，它在操作系统中有什么作用？

**管程（Monitor）\**是一种用于\**进程同步**的高级抽象机制，它将共享资源的访问与管理封装在一个模块中，通过**条件变量**和**同步机制**来确保进程对资源的互斥访问。它是操作系统中用于解决并发编程问题的重要工具。 管程的主要作用包括：

1. **互斥访问**：保证多个进程不能同时访问同一个共享资源。
2. **条件同步**：通过条件变量协调多个进程的执行顺序。
3. **简化并发编程**：通过封装复杂的同步逻辑，提供更易用的接口。