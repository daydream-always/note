# 计算机网络 应用层

## HTTP 请求报文和响应报文是怎样的？

#### 简要回答

1. HTTP请求报文：

   - 请求行：包含请求方法（GET、POST等）、URL、HTTP版本。
   - 请求头：包含客户端信息、请求内容类型、语言、Cookie等。
   - 请求体：仅在某些请求方法（如POST）中包含，包含实际的数据内容。
   
2. HTTP响应报文：

   - 状态行：包含HTTP版本、状态码（如200、404等）、状态描述。
   - 响应头：包含服务器信息、缓存策略、内容类型等。
   - 响应体：包含返回的实际数据（如HTML页面、JSON等）。

## HTTP 请求中常见的状态码有哪些？它们分别代表什么含义？

#### 简要回答

- 面试最高频的十个HTTP状态码，如下：

  1. **200**：**OK**，表示请求已被**正确**处理（如网页加载成功、API 成功返回数据）。
  2. **301**：**Moved Permanently**，表示资源**永久**重定向到新 URL（如网站更换域名，旧链接跳转）。
  3. **302**：**Found**，表示资源**临时**重定向到新 URL（如登录后跳转回原页面）。
  4. **304**：**Not Modified**，表示资源**未修改**，客户端直接使用本地缓存（缓存机制的核心状态码）。
  5. **400**：**Bad Request**，表示客户端**请求**格式**错误**（如参数缺失、JSON 语法错误）。
  6. **401**：**Unauthorized**，表示**未认证**（如未登录时访问需权限的接口）。
  7. **403**：**Forbidden**，表示**无权限**访问资源（如普通用户访问管理员接口）。
  8. **404**：**Not Found**，表示资源**不存在**（如 URL 路径错误、文件被删除）。
  9. **500**：**Internal Server Error**，表示**服务器内部错误**（如代码异常、数据库崩溃）。
  10. **503**：**Service Unavailable**，表示**服务暂时不可用**（如服务器维护、过载熔断）。

------

#### 详细回答

##### 一、2xx（成功类）

1. 200：
   - **定义**：**OK**，表示请求已被服务器**正确**处理；**GET**请求一般返回资源内容，而**POST**请求则可能返回操作结果或新资源链接。
   - **典型场景**：访问网页成功加载（HTML 内容）；API 返回 JSON 数据。

##### 二、3xx（重定向类）

1. 301：
- **定义**：**Moved Permanently**，表示请求的资源已**永久重定向**到新 URL，客户端应更新书签或链接；浏览器会**缓存此重定向**，后续请求直接访问新 URL。
   - **典型场景**：网站更换域名（如 `programmercarl.com` → `notes.kamacoder.com`）；HTTP 升级 HTTPS 的全局跳转。

2. 302：
- **定义**：**Found**，表示资源**临时重定向**到新 URL，客户端后续请求可能仍访问原 URL；浏览器默认对 `302` 使用 **GET** 方法重定向，即使原请求是 **POST**。
   - **典型场景**：登录后临时跳转到用户主页；OAuth 授权流程中的回调跳转。

3. 304：
   - **定义**：**Not Modified**，表示资源**未修改**，客户端可直接使用缓存副本；服务器不返回响应体，仅返回 `304` 状态和缓存相关头部。
   - **典型场景**：浏览器缓存验证（通过 `If-Modified-Since` 请求头）；CDN 节点缓存有效性检查。

##### 三、4xx（客户端错误类）

1. 400：
- **定义**：**Bad Request**，客户端请求存在**语法或参数错误**，服务器无法处理；需结合响应体中的错误描述排查问题。
   - **典型场景**：请求体 JSON 格式错误；缺少必填参数导致请求格式错误。

2. 401：
- **定义**：**Unauthorized**，请求**未提供有效身份凭证**，需认证后重试。
   - **典型场景**：未登录用户访问需要权限的接口；Token 过期或无效。

3. 403：
- **定义**：**Forbidden**，客户端身份已认证，但**无权访问**目标资源；隐藏无权限资源时可能返回 `404` 替代。
   - **典型场景**：普通用户尝试访问管理员接口；IP 地址被列入黑名单。

4. 404：
   - **定义**：**Not Found**，服务器**未找到**请求的资源；有可能是服务器故意隐藏资源存在性（如避免敏感信息泄露）。
   - **典型场景**：URL 路径错误；资源已被删除（如用户访问已下架商品）。

##### 四、5xx（服务器错误类）

1. 500：
- **定义**：**Internal Server Error**，**服务器内部错误**，无法完成请求；开发环境下应返回详细错误堆栈，生产环境需隐藏敏感信息。
   - **典型场景**：代码未处理的异常（如空指针、数据库连接失败）；服务器配置错误。

2. 503：
   - **定义**：**Service Unavailable**，服务器**暂时**无法处理请求（通常因过载或维护）。
   - **典型场景**：服务器维护窗口期；高并发流量导致服务熔断（如秒杀活动）。

------

#### 知识拓展

- 高频HTTP状态码详解，如下图所示：

   

  ![HTTP_Status_Code.jpg](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/3daf0b4c-33d5-4b40-b6ad-9d85f78df35f.jpg)

- 更多HTTP状态码，如下表所示：

  

  | **状态码** | **状态码英文名称**                  | **中文描述**                                                 |
  | ---------- | ----------------------------------- | ------------------------------------------------------------ |
  | `100`      | **Continue**                        | 继续。客户端应继续其请求                                     |
  | `101`      | **Switching Protocols**             | 切换协议。服务器根据客户端的请求切换协议（如升级到 WebSocket） |
  | `200`      | **OK**                              | 请求成功。一般用于 GET 与 POST 请求                          |
  | `201`      | **Created**                         | 已创建。成功请求并创建了新的资源                             |
  | `202`      | **Accepted**                        | 已接受。已接受请求但未处理完成（常用于异步任务）             |
  | `203`      | **Non-Authoritative Information**   | 非授权信息。返回的元信息来自副本而非原始服务器               |
  | `204`      | **No Content**                      | 无内容。服务器成功处理但未返回内容（如 DELETE 请求）         |
  | `205`      | **Reset Content**                   | 重置内容。客户端应重置文档视图（如清空表单）                 |
  | `206`      | **Partial Content**                 | 部分内容。服务器成功处理了部分 GET 请求（如断点续传）        |
  | `300`      | **Multiple Choices**                | 多种选择。资源有多个地址可选，需客户端选择                   |
  | `301`      | **Moved Permanently**               | 永久移动。资源已永久重定向到新 URI（浏览器会缓存新地址）     |
  | `302`      | **Found**                           | 临时移动。资源临时重定向到新 URI（后续请求仍用原地址）       |
  | `303`      | **See Other**                       | 查看其他地址。强制客户端用 GET 方法访问新 URI（常用于 POST 后重定向） |
  | `304`      | **Not Modified**                    | 未修改。客户端缓存资源有效，无需重新传输                     |
  | `305`      | **Use Proxy**                       | 使用代理。请求必须通过代理访问（现代浏览器已弃用）           |
  | `306`      | **Unused**                          | 已废弃（原设计用于后续请求的代理，现被 307/308 替代）        |
  | `307`      | **Temporary Redirect**              | 临时重定向。保持原请求方法重定向（如 POST 请求临时重定向）   |
  | `400`      | **Bad Request**                     | 客户端请求语法错误，服务器无法理解                           |
  | `401`      | **Unauthorized**                    | 未认证。需提供有效身份凭证（如登录 Token）                   |
  | `402`      | **Payment Required**                | 保留状态（实际用于支付场景，如 Stripe API 调用）             |
  | `403`      | **Forbidden**                       | 禁止加粗访问。已认证但无权限访问资源                         |
  | `404`      | **Not Found**                       | 未找到。服务器无法根据请求找到资源                           |
  | `405`      | **Method Not Allowed**              | 方法禁用。请求的 HTTP 方法不被允许（如用 GET 访问仅支持 POST 的接口） |
  | `406`      | **Not Acceptable**                  | 不可接受。服务器无法提供客户端要求的媒体类型（如只支持 JSON 但请求 XML） |
  | `407`      | **Proxy Authentication Required**   | 代理认证要求。需通过代理服务器认证                           |
  | `408`      | **Request Time-out**                | 请求超时。服务器等待客户端发送请求时间过长                   |
  | `409`      | **Conflict**                        | 冲突。请求与服务器当前状态冲突（如并发编辑资源版本冲突）     |
  | `410`      | **Gone**                            | 已删除。资源永久不存在（与 404 不同，明确表示资源被主动删除） |
  | `411`      | **Length Required**                 | 需要有效长度。请求必须包含 `Content-Length` 头部             |
  | `412`      | **Precondition Failed**             | 前提条件失败。请求头中的条件不满足（如 `If-Match` 校验失败） |
  | `413`      | **Request Entity Too Large**        | 请求实体过大。服务器拒绝处理（如上传文件超过限制）           |
  | `414`      | **Request-URI Too Large**           | URI 过长。请求的 URL 超过服务器限制（如 GET 参数过长）       |
  | `415`      | **Unsupported Media Type**          | 不支持的媒体类型。服务器无法处理请求附带的格式（如上传文件类型不被支持） |
  | `416`      | **Requested range not satisfiable** | 请求范围无效。客户端要求超出资源的可用范围（如请求文件末尾之外的数据） |
  | `417`      | **Expectation Failed**              | 预期失败。服务器无法满足 `Expect` 请求头的要求（如 `Expect: 100-continue` 不被支持） |
  | `500`      | **Inte**加粗**rnal Server Error**   | 服务器内部错误。代码异常或配置错误                           |
  | `501`      | **Not Implemented**                 | 未实现。服务器不支持请求的功能（如使用未启用的 HTTP 方法）   |
  | `502`      | **Bad Gateway**                     | 网关错误。代理服务器从上游收到无效响应（如后端服务崩溃）     |
  | `503`      | **Service Unavailable**             | 服务不可用。服务器过载或维护中（可通过 `Retry-After` 头指定重试时间） |
  | `504`      | **Gateway Time-out**                | 网关超时。代理服务器未及时从上游获取响应（如后端服务响应超时） |
  | `505`      | **HTTP Version not supported**      | 不支持的 HTTP 版本。服务器不支持请求中的协议版本（如请求 HTTP/3 但服务器仅支持 HTTP/1.1） |

## GET 请求和 POST 请求的区别是什么？

#### 功能不同

get是请求资源，而post是提交数据

因为是请求资源，所以get重复执行不会改变资源状态，它是幂等，而post每次都会更改资源，它是非幂等的

#### 数据传输方式不同

get把参数直接加在url之后，而post把参数放在请求体里

因此get是显示传输，安全性会更差，也会有长度限制，而post更安全，也没有长度限制

#### 缓存不同

get可以缓存，而post默认不缓存 

![1733368456239.png](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/67511a919ce8f-phpAFdt6a.png)

## HTTP请求方式有哪些？

#### http1.0提供了三种请求方式

分别是get,post和head

get用于请求服务器资源，它是幂等的

head与get类似，但它只获取报文首部，而不获取报文主体，它也是幂等的

post用于向服务器提交数据，它不是幂等的

#### http1.1增加了五种请求方式

分别是put, delete, trace, options和connect

put上传资源到服务器，用于更新或创建，因此它是幂等的

delete删除资源

trace回显收到的请求，用于调试

options查看服务器支持的http方法，这几个请求方式都是幂等的

connect建立隧道连接，用于代理http请求，它不是幂等的

#### http1.1之后又增加了patch

Patch对资源部分更新，它非幂等 

![1733367481143.png](http://cdn.kamacoder.com/675116bfe3cac-phpeZxKqJ.png)

## 什么是强缓存和协商缓存？它们的工作原理是什么？

强缓存和协商缓存是HTTP缓存的两种类型，都是为了减少服务器的负担和提高网页加载速度。

**强缓存**：不过服务器，在本地缓存获取资源，包括Expires和Cache-Control

1. Expires是设置一个时间，当超过时间时表示缓存过期，需要重新向服务器发起请求，在时间范围内则使用缓存
2. 缺点：本地时间不准确时，判断不准确
3. Cache-Control则是通过Http响应头的Cache-Control字段实现，通过设置max-age来表示与上次请求的时间间隔，在时间间隔内则直接使用缓存

**协商缓存**：需要过服务器，在强缓存失效时使用，通过Http响应头的ETag或Last-Modified字段与服务器进行验证，判断资源是否被修改，如果修改则状态码200，返回新资源，更新本地缓存，如果没修改则状态码304，则使用本地缓存

1. Last-Modified：资源最后使用时间，在响应头的字段，当客户端读取到该字段时，会在下一次请求的请求头写到If-Modified-Since字段，包含服务器第一次修改给的时间。服务器接收到If-Modified-Since的值后，会与Last-Modified比较，如果相同，则说明资源没有修改，使用本地缓存，如果相同，则返回新资源，更新本地缓存
2. 缺点：对比的是修改时间。比如修改文件名后改回来，但是文件不变，时间修改了，导致缓存失效。文件修改时间记录是秒级，如果文件于毫秒级被修改，但是修改时间不变，导致缓存不更新。
3. ETag：根据文件指纹，即文件hash值比对。ETag是服务器根据文件内容计算的标识符，跟资源一起返回给客户端。客户端在请求头部字段If-None-Match携带ETag值，服务器则进行比对，如果相同则使用本地缓存，不同则证明资源更新，需要更新ETag值，返回新资源

## HTTP1.0 和 HTTP1.1 的区别是什么？

#### http 1.1 和 http 1.0 的区别主要体现在以下几个方面：

- 1. 持久链接：

  - http 1.0 中是短连接，每次请求都会重新建立 TCP 连接，这种方式增加了延迟和资源消耗。
  - http 1.1 中引入了持久连接，建立一次 TCP 连接之后，只有通信双方没有一方主动断开连接，连接就不会断开。但如果长连接超过一定时间没有数据交互，服务端也会主动断开连接。
  
- 2. 管道化（pipeline）：

  - http 1.0 不支持管道化，只能等前一个请求响应之后，才能发送后续的请求。
  - http 1.1 支持管道化，客户端第一个请求发出后，不用等到响应，就可以继续发后续的请求，但服务端只能按顺序返回响应。pipeline 解决了请求队头阻塞的问题，但如果第一个响应处理时间长，就会出现队头阻塞的问题。而且实际上 http/1.1 管道化技术不是默认开启，而且浏览器基本都不支持。
  
- 3. 请求头和响应头的改进：

  - http 1.0 请求头和响应头比较简单，无法处理复杂的场景。
  - http 1.1 引入了一些新的字段，改进了对请求和响应的描述，比如改进有：增加了 host 、cache-control 等字段。
  
- 4. 错误处理：

  - http 1.0 响应状态码较少。
  - http 1.1 增加了更多的响应状态码，如206（partial content 部分内容）、409（conflict 请求与当前服务器冲突）/410（gone 资源已永久删除）等状态码。
  
- 5. 请求方法：

  - http 1.0 仅支持 GET POST HEAD。
  - http 1.1 增加了更多的请求方法，如 PUT DELETE OPTIONS等。
  
- 6. 身份认证：

  - http 1.0 支持基本的身份认证机制，但没有 http 1.1 灵活。
- http 1.1 引入了更多的身份认证机制，包括 Authorization 和 WWW-Authenticate 头部，提供了更安全和灵活的认证机制。

## HTTP2.0 与 HTTP1.1 相比有哪些主要改进？

#### **二进制协议**

- HTTP/1.1 采用文本格式传输数据
- HTTP/2.0 采用二进制格式传输数据，解析更高效

#### **多路复用**

- HTTP/1.1 使用串行方式发送请求和响应
- HTTP/2.0 支持多路复用，允许在单个TCP连接上并行交错发送多个请求和响应，解决了`HTTP/1.1` 中的**队头阻塞**问题。

#### **头部压缩**

- HTTP/1.1 支持`Body`压缩，`Header`不支持压缩
- HTTP/2.0 引入了`HPACK` 压缩算法，对请求和响应的头部信息进行压缩，减少了冗余头部信息的传输，提高了传输效率。

#### **服务器推送**

- HTTP/1.1 需要客户端自己发送请求来获取相关资源。
- HTTP/2.0允许服务器主动推送资源给客户端，而不需要客户端明确请求，这可以减少页面加载时间。

## HTTP3.0 有了解过吗？它与之前的版本有哪些主要不同？

#### 主要特点

HTTP3.0最大的特点是基于UDP+QUIC协议，而不是像上几个版本那样依赖TCP。

#### TCP 缺点

- **队头阻塞问题（TCP级别**）：一个包丢失会导致整个连接的多个请求都必须等待重传。
- **握手慢**：TCP+TLS连接过程至少需要握手三次才能建立，首次访问延迟高
- **HTTP3.0的目标是彻底解决这些问题**

## HTTP 的 Keep-Alive 是什么？它在网络通信中有什么作用？

**HTTP Keep-Alive**是一种应用层机制，称为 HTTP 长连接，允许客户端和服务端在单个 TCP 连接上复用多个 HTTP 请求和响应，避免频繁建立和关闭连接的开销。

- 避免重复 TCP 三次握手（建立连接）和四次挥手（关闭连接）的时间消耗
- 复用同一连接传输多个请求，减少服务器和客户端的资源占用

**TCP的Keepalive**，传输层机制，用于检测 TCP 连接是否存活，避免因网络中断或对端异常导致的“僵尸连接”占用资源。当`TCP`连接建立后，如果一段时间内没有任何数据传输，`TCP Keepalive`会发送探测包来检查连接是否仍然有效。

## DNS 查询过程是怎样的？它是如何实现域名解析的？

#### DNS查询分为迭代查询和递归查询

#### 对于迭代查询

当需要查询域名对应的ip地址时，首先查看本地是否缓存了这个域名的ip地址，如果有就直接使用

如果本地没有，就查询本地的DNS服务器，这个通常是有通信服务商来提供的

如果本地DNS服务器没有，它就会去查询根DNS服务器，根DNS服务器会告知本地DNS服务器该查询那个顶级DNS服务器

接下来本地DNS服务器向该顶级DNS服务器发送查询请求，顶级DNS服务器会告知本地DNS服务器下一步该查询哪个权限DNS服务器

最后本地DNS服务器查询权限DNS服务器，获得该域名的IP地址，缓存下来并发给主机，主机也缓存在本地

#### 递归查询与迭代查询类似

不同之处在于迭代查询是本地DNS服务器去依次询问根DNS服务器，顶级DNS服务器以及权限DNS服务器。而递归查询是由根DNS服务器去查询顶级DNS服务器，顶级DNS服务器再查询权限DNS服务器，获得结果再依次返回 

![1734007491971.png](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/675adac8ee5e8-phpDS5WI4.png)

## CDN 是什么？它在网络传输中有什么作用？

CDN是一种分布式网络服务，通过将内容存储在分布式的服务器上，使用户可以从距离较近的服务器获取所需的内容，加快内容获取的速度。

- **就近访问**：CDN 在全球范围内部署了多个服务器节点，用户的请求会被路由到距离最近的 CDN 节点，来获取资源。
- **内容缓存**：CDN 服务器会缓存静态资源，如图片、样式表等。当用户请求访问这些资源时，CDN 会首先检查是否已经缓存了该资源。如果有缓存，CDN 节点会直接返回缓存的资源，如果没有缓存所需资源，它会从源服务器（原始服务器）回源获取资源，并将资源缓存到节点中，以便以后的请求。
- **可用性**：即使某些节点出现问题，用户请求可以被重定向到其他健康的节点。

## Cookie 和 Session 是什么？它们在网络通信中扮演什么角色？有什么区别？

Cookie和Session都用于管理用户的状态和身份。Cookie通过客户端记录信息确定用户身份，Session通过服务端记录信息确定用户身份。

#### cookie

- Cookie是存储在用户浏览器中的小型文本文件，用于在用户和服务器之间传递数据。通常服务器会将一个Cookie或多个Cookie发送到用户浏览器，然后浏览器将这些Cookie存储在本地。
- 服务器在接收到来自客户端的请求之后，能够分析存放在请求头中的Cookie得到客户端特有的信息，从而动态生成相应的内容。

#### session

客户端访问服务器时，服务器把客户端信息以某种形式记录在服务器上。这就是Session。用于维护用户登陆状态和用户临时数据等，客户端访问服务器时，服务器会为每个用户分配一个唯一的sessionID，通常存储在cookie中

#### 区别

- **存储位置**上，cookie数据存储在用户的浏览器中，而session数据存储在服务器上
- **数据容量**上，cookie的存储容量相对较小，而session的存储容量一般没有固定限制，取决于服务器的配置和资源
- **安全性**上，由于cookie存储在用户浏览器中， /因而很容易被读取和纂改/ ，而session存储在服务器上没有那么容易
- **生命周期**上，cookie /可设置过期时间/ ，而session依赖会话的持续时间或用户活动
- **传输方式**上，cookie在每次HTTP请求中都会被自动发送到服务器，而sessionID通常通过cookie或url参数传递

## HTTP 请求中的头部字段有哪些常见的类型？它们各自的作用是什么？

HTTP 请求头部字段是客户端和服务器之间传递元信息的重要工具，涵盖了内容类型、语言、压缩方式、认证信息等内容

|   **头部字段**    |            **作用**            |                      **示例**                       |
| :---------------: | :----------------------------: | :-------------------------------------------------: |
|     **Host**      |     指定目标主机名和端口号     |               `Host: www.example.com`               |
|  **User-Agent**   |         指定客户端信息         |              `User-Agent: Mozilla/5.0`              |
|    **Accept**     |    指定可接受的响应内容类型    |        `Accept: text/html, application/json`        |
|    **Cookie**     |  传递客户端存储的 Cookie 数据  |             `Cookie: session_id=12345`              |
| **Authorization** |        传递身份验证信息        | `Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==` |
| **Content-Type**  |      指定请求体的内容类型      |          `Content-Type: application/json`           |
|    **Referer**    |        指定请求来源页面        |         `Referer: https://www.google.com/`          |
|     **Range**     | 请求资源的部分内容（断点续传） |               `Range: bytes=500-999`                |

## 什么是 HTTP 管道化？它在网络通信中有什么作用？

- HTTP管道化（Pipelining）定义：

  - HTTP管道化是一种允许客户端在接收到前一个请求的响应之前，直接发送多个请求的技术，用于提高网络通信效率。
  - 适用于HTTP/1.1，但需要客户端和服务器的支持。
  
- 作用：

  - **减少延迟**：通过消除请求和响应之间的等待时间，提高传输效率。
  - **提高吞吐量**：允许多个请求同时发送，减少连接开销。
  - **节省资源**：通过复用单个TCP连接，减少资源占用。

## HTTP/2 相比 HTTP/1.1 有哪些主要改进？这些改进带来了哪些好处？

1. HTTP/2的主要改进：

   - **二进制分帧**：HTTP/2采用二进制格式，而非HTTP/1.1的纯文本格式，提高解析效率。
   - **多路复用**：在一个TCP连接上支持多个请求和响应同时传输，解决HTTP/1.1的队头阻塞问题。
   - **头部压缩**：通过HPACK算法压缩HTTP头部，减少网络带宽占用。
   - **服务器推送**：允许服务器主动将资源推送到客户端，无需客户端请求。
   - **流优先级**：支持流的优先级和依赖关系管理，优化资源分配。
   
2. 改进带来的好处：

   - **性能提升**：减少延迟，提高网页加载速度。
   - **带宽节省**：头部压缩与服务器推送降低了网络流量消耗。
   - **优化用户体验**：更快的响应时间与更高的吞吐量提升了用户体验。

## 什么是 WebSocket？它在网络通信中有什么作用？

- **定义**：WebSocket是一种在单个TCP连接上进行全双工通信的协议，允许客户端和服务器之间建立持久的连接。
- **作用**：它在网络通信中实现了实时数据交换，广泛用于需要低延迟和双向通信的应用场景，如在线游戏、实时聊天和股票交易等。

## 什么是 HTTP/2 的服务器推送？它在网络通信中有什么作用？

**服务器推送**（Server Push）是HTTP/2中的一种特性，它允许服务器主动向客户端推送资源，而不是仅在客户端请求时才发送数据。这种机制可以在客户端发起请求之前，服务器就预先发送某些资源，以减少等待时间，提升页面加载速度。 **作用：**

- **减少延迟**：服务器可以在客户端需要资源之前，提前推送那些预计会被请求的资源。
- **提高效率**：避免了客户端发起多次请求的往返时间，尤其是在加载复杂网页时。
- **优化加载性能**：例如，服务器可以推送CSS、JavaScript文件或图片等，帮助浏览器更早地处理和渲染页面。

## HTTP 请求中的 Content-Type 头部字段有什么作用？常见的取值有哪些？

`Content-Type` 是 HTTP 请求和响应报文的头部字段之一，用于指明 **消息主体的数据类型**，告诉接收方如何解析消息内容。

### **HTTP 请求中 `Content-Type` 头部字段的作用**

`Content-Type` 是 HTTP 请求和响应报文的头部字段之一，用于指明 **消息主体的数据类型**，告诉接收方如何解析消息内容。它对客户端和服务器都很重要，是确保数据传输和处理正确的关键。

------

### **作用**

1. 指明数据格式
   - 客户端使用 `Content-Type` 告诉服务器请求体的内容格式。
   - 服务器使用 `Content-Type` 告诉客户端响应体的内容格式。
2. 正确解析数据
   - 接收方通过 `Content-Type` 值确定如何处理数据。
   - 例如：`Content-Type: application/json` 表示数据是 JSON 格式，接收方需要按 JSON 格式解析。
3. 支持多样化的数据类型
   - 支持文本、图片、视频、音频等多种格式的数据传输。
   - 不同的格式适用于不同的场景（如表单提交、文件上传）。