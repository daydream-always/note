# 消息中间件

## MQ消息积压以及处理方案

这种时候只能操作临时扩容，以更快的速度去消费数据了

- 增加多个消费者，加速消费
- 新建topic引流，将消息引导别的程序中，洪水一个道理。

## 如何保证MQ中的消息不丢失

### **生产者**丢失消息

1. 可以选择使用rabbitmq提供是事务功能，就是生产者在发送数据之前开启事务，然后发送消 息，如果消息没有成功被rabbitmq接收到，那么生产者会受到异常报错，这时就可以回滚事 务，然后尝试重新发送;如果收到了消息，那么就可以提交事务。

   **缺点:**rabbitmq事务已开启，就会变为同步阻塞操作，生产者会阻塞等待是否发送成功，太 耗性能会造成吞吐量的下降。

2. 可以开启confirm模式。在生产者哪里设置开启了confirm模式之后，每次写的消息都会分配 一个唯一的id，然后如何写入了rabbitmq之中，rabbitmq会给你回传一个ack消息，告诉你 这个消息发送OK了;如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这 个消息失败了，你可以进行重试。而且你可以结合这个机制知道自己在内存里维护每个消息 的id，如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发

二者不同

事务机制是同步的，你提交了一个事务之后会阻塞住，但是confirm机制是异步的，发送消息 之后可以接着发送下一个消息，然后rabbitmq会回调告知成功与否。

一般在生产者这块避免丢失，都是用confirm机制。

#### rabbitmq自己弄丢了数据

- 设置消息持久化到磁盘。设置持久化有两个步骤:
  - 创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数 据，但是不会持久化queue里面的数据。
  - 发送消息的时候讲消息的deliveryMode设置为2，这样消息就会被设为持久化方式，此时 rabbitmq就会将消息持久化到磁盘上。

必须要同时开启这两个才可以。

- 而且持久化可以跟生产的confirm机制配合起来，只有消息持久化到了磁盘之后，才会通知生 产者ack，这样就算是在持久化之前rabbitmq挂了，数据丢了，生产者收不到ack回调也会进 行消息重发。

### 消费者弄丢了数据

使用rabbitmq提供的ack机制，首先关闭rabbitmq的自动ack，然后每次在确保处理完这个

消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack

## 如何保证MQ中消息的顺序性

- **为什么要保证顺序**

消息队列中的若干消息如果是对同一个数据进行操作，这些操作具有前后的关系，必须要按 前后的顺序执行，否则就会造成数据异常。 举例:比如通过mysql binlog进行两个数据库的数据同步，由于对数据库的数据操作是具有 顺序性的，如果操作顺序搞反，就会造成不可估量的错误。比如数据库对一条数据依次进行 了 插入->更新->删除操作，这个顺序必须是这样，如果在同步过程中，消息的顺序变成了 删 除->插入->更新，那么原本应该被删除的数据，就没有被删除，造成数据的不一致问题。

- 出现顺序错乱的场景

1. 一个queue => 多个consumer去消费，这样就会造成顺序的错误，consumer从MQ里面读取 数据是有序的，但是每个consumer的执行时间是不固定的，无法保证先读到消息的 consumer一定先完成操作，这样就会出现消息并没有按照顺序执行，造成数据顺序错误。

![image-20240116155412010](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/image-20240116155412010.png)

1. 一个queue => 一个consumer，但是consumer里面进行了多线程消费，这样也会造成消息 消费顺序错误。

![image-20240116155435553](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/image-20240116155435553.png)

- **保证消息的消费顺序**

1. 拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点;这样 也会造成吞吐量下降，可以在消费者内部采用多线程的方式去消费。

![image-20240116155450149](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/image-20240116155450149.png)

1. 一个queue对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底 层不同的worker来处理

![image-20240116155505806](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/image-20240116155505806.png)

### 发表评论

KamaCoder546472

10/19/25, 12:07 PM

笔记真的很有用！谢谢卡哥开源！ദ്ദി˶˃ ᵕ ˂ )✧