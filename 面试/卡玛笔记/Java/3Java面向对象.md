![img](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/2025-09-12_12-27-28.jpg)

**[笔记网站](https://programmercarl.com/other/project_kamabiji.html)是一个基础的项目，如果你刚刚学完Java基本语法，做这个项目练练手非常合适。还可以写在简历上，用来找实习**。

# Java 面向对象编程（OOP）

学习导图：

![img](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/_Javaleiheduixiang_posper.png)

## 什么是面向对象编程（OOP）？说一说Java面向对象三大特性？（考点：OOP定义、封装、继承、多态）【简单】

#### 简要回答

1. 封装（Encapsulation）：
   - **概念**：是指将**数据**（属性）和**操作数据的方法**（行为）**捆绑**在一起形成一个**独立的单元**（类/对象），并**隐藏其内部实现细节**，而是仅通过公共方法对外提供访问接口。
   - **好处**：数据被保护在封装体内部，对外隐藏实现细节。
2. 继承（Inheritance）：
   - **概念**：是指让类与类之间产生**父子关系**。它允许一个类（子类）从另一个已存在的类（父类）中继承属性和方法，从而实现代码的复用，并建立类之间的层级关系。
   - **好处**：提高代码复用性，类与类之间建立“is-a”的关系。
3. 多态（Polymorphism）：
   - **概念**：是指允许**父类引用指向子类对象**，并在运行时根据对象的实际类型调用相应的方法。它使得“一个接口，多种实现”成为现实。
   - **好处**：提高代码的灵活性和可扩展性。

------

#### 详细回答

##### 1. 封装（Encapsulation）

- 定义：
  - 封装是指将对象的**数据**（属性）和**操作数据的方法**（行为）**捆绑**在一起形成一个**独立的单元**（类/对象）。
  - 同时，它通过控制访问权限来 **隐藏对象的内部实现细节**，而只对外提供**有限的、受控的**公共接口进行交互。
- **JavaBean**：JavaBean 是封装的典型应用，符合JavaBean标准的类，必须是具体，公共的；并且不但具有空参构造，通常也需要写出它的带参构造；成员变量全部用 private关键字 修饰，并且要提供用来操作这些成员变量的 setter和getter方法。
- 关键实现：
  - **访问修饰符**：主要通过 `private` 关键字来实现数据和内部方法的隐藏。`public` 关键字则用于暴露对外接口。
  - **`this` 关键字**：在类的方法内部，`this` 关键字用于引用当前对象的实例，常用于解决“成员变量和形参重名”的问题，以及在构造器中调用其他构造器。
  - **与抽象的关系**：封装与抽象紧密相关，**抽象**是识别事物的共同特征和行为的过程，而封装则将这些抽象出来的特征和行为及其实现细节捆绑并隐藏起了。
- 优点：
  - **数据安全性高**：数据被保护在封装体内部，外部不能随意访问和修改，保证了数据完整性。
  - **降低耦合度**：只要接口不变，类内部实现的变化就不会影响外部调用者。
  - **提高代码复用性**：封装好的组件可以更容易地在不同项目中复用。

##### 2. 继承（Inheritance）

- 定义：
  - 继承是面向对象中实现 **代码复用** 和 建立**类之间层级关系（“is-a”关系）** 的机制。它允许一个类（**子类/派生类**）从另一个已存在的类（**父类/基类/超类**）中继承其属性和方法。
  - 子类可以在继承的基础上，添加新的属性和方法，或者重写（Override）父类的方法，以实现特有的行为。
  - 子类不能直接访问父类的私有（`private`）成员，但可以通过父类提供的 `public` 或 `protected` 方法间接访问。
- 特点：
  - **单继承**：Java 类只支持单继承，即**一个类只能直接继承一个父类**。
  - **多层继承**：但是 Java 支持多层继承，即一个子类可以有自己的子类。
  - **传递性**：子类不但可以继承直接父类的非私有成员，还可以继承直接父类的父类的非私有成员。
  - **构造器不被继承**：子类不继承父类的构造器，但子类构造器在执行前会**隐式或显式地**调用父类的构造器。
- 关键实现：
  - **`extends` 关键字**：Java中如果使用**继承**，需要用到 **extends关键字**，在定义子类时，子类类名后跟上“extends + 要继承的父类类名”，即可。
  - **`super` 关键字**：用于在子类中访问父类的成员（属性和方法），特别是调用父类的构造器（如`super()`）来完成属性的初始化。
  - **方法重写（Override）**：子类对父类中已有的方法进行重新实现，以适应子类的特定行为。方法重写是实现多态的基础。
- 优点：
  - **提高可维护性**：修改父类中的公共逻辑，可以影响所有子类。
  - **模拟现实世界**：继承关系可以体现现实世界中的层级结构 和 “is-a”的关系。
- 缺点：
  - **高耦合性**：子类与父类之间形成强耦合关系，不符合“**低耦合，高内聚**”的程序设计要求。并且子类暴露了父类的实现细节（“白盒复用”）。
  - **灵活性限制**：Java 的单继承机制限制了类的功能扩展性。

##### 3. 多态（Polymorphism）

- 定义：
  - 是指“**一个接口，多种实现**”。在 Java 中，多态主要体现在——允许**父类引用指向子类对象**，并在运行时根据对象的实际类型调用相应的方法，即动态绑定机制。
- 特点：
  - **运行时绑定（动态绑定）**：这是多态的核心机制，编译器在编译时只知道引用变量的类型（静态类型），但在程序运行时，JVM 会根据对象的实际类型（动态类型）来查找并调用相应的方法。
  - **提高可扩展性**：增加新的子类时，无需修改现有代码，只需让新子类重写父类方法。
- 实现多态的三个必要条件：
  1. **继承或实现关系**：必须存在子父类继承关系或接口实现关系。
  2. **方法重写（Override）**：子类必须重写父类的方法（或实现接口方法）。
  3. **父类引用指向子类对象**。
- 优点：
  - **可维护性高**：修改具体实现不影响调用方。
  - **可扩展性强**：新增子类只需实现父类接口或重写方法，无需修改调用方代码。
- 缺点：
  - **父类引用不能直接使用子类的特有成员**：这是多态的一个限制。例如，`Animal animal = new Dog();`，`animal` 引用对象无法直接调用 `Dog` 类特有的方法，除非进行强制类型转换。

------

#### 知识拓展

1. 三大特性——封装，示意图如下：

   ![OOP_encapsulation.jpg](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/fb2d5100-43b7-4097-9ef9-9f932a47e7ac.jpg)

2. 面试官可能的追问1：封装、继承、多态这三大特性之间有何内在联系？

   - **封装是基础**：它既保护了对象的内部状态，又隐藏了实现细节，为继承提供了安全的基石。没有良好的封装，继承可能导致子类随意破坏父类内部，使得系统脆弱。
   - **继承是前提**：它建立了类之间的“is-a”层级关系，实现了代码复用，并为多态提供了父类引用和方法重写的机制。
   - **多态是目的**：它在继承的基础上，通过父类引用指向子类对象，实现了运行时动态绑定，使得代码更加灵活、可扩展性变强，是面向对象设计最终追求的目标之一。

3. 面试官可能的追问2：面向对象设计中，为什么提倡“组合优于继承”？

   - **继承的强耦合性**：继承是一种“白盒复用”，子类会暴露父类的实现细节，父类内部的修改可能影响所有子类，导致“脆弱的基类问题”。
   - **继承的单一性**：Java 只支持单继承，限制了代码复用的灵活性。
   - **组合的优势**： ① **弱耦合**：组合是“黑盒复用”，被组合的对象内部实现对外部是隐藏的，只通过接口交互，降低了耦合度。 ② **高灵活性**：一个类可以组合多个对象，实现多重功能，且可以在运行时动态改变组合关系。 ③ **易于测试**：组合的模块更独立，易于进行单元测试。

## 在Java中，类和对象的关系是什么？（考点：类定义、对象实例化）【简单】

类定义了对象的结构（字段）和操作（方法），但是没有实际的数据，类似于一个模具，而对象是根据特定数据实例化出来的产品。

## 解释Java中的封装原则，并给出一个实例。（考点：封装性、访问修饰符、getter/setter方法）【简单】

想象一下，你去了一家餐厅吃饭。餐厅提供了菜单（类），而菜单上的每道菜就是餐厅的服务（方法）。你并不知道餐厅后厨的具体操作流程，只知道如果点了某道菜，就会有相应的服务（返回结果）。这就是封装的精髓：外面的人只能知道如何与餐厅互动（即接口），而不需要关心餐厅具体是如何做菜的（内部实现）。

封装就像是你将厨房里的操作藏在后面，而给顾客提供一个干净整洁的菜单和服务。通过封装，我们隐藏了不需要暴露给外部的细节，确保外部只通过接口（方法）来操作内部数据，从而使得代码更加安全、灵活和易于维护。

### 封装的原则：

1. **数据隐藏**：不允许外部直接访问对象的内部数据。数据和方法通过“公共接口”与外部交互。
2. **提高安全性**：通过控制数据的访问权限，避免直接修改内部状态，确保数据的完整性。
3. **简化复杂性**：外部只需要关心如何调用方法，而不需要了解内部的复杂实现。

### 具体讲解：

#### 封装的实现方法：

- 将 **类的属性（字段）设置为私有（private）**，即外部无法直接访问。
- 提供 **公共的访问方法（getter 和 setter）**，让外部通过这些方法来访问和修改私有属性。

### 示例：银行账户（封装的应用）

我们通过一个银行账户的例子来理解封装：

1. 我们定义一个 `BankAccount` 类，拥有私有的账户余额（`balance`）和一些公共的方法来访问和修改余额。
2. 外部代码不能直接修改余额，而是必须通过类提供的 `deposit` 和 `withdraw` 方法来操作。

```
class BankAccount {
    // 私有属性
    private double balance;

    // 公共的构造方法
    public BankAccount(double initialBalance) {
        if (initialBalance >= 0) {
            this.balance = initialBalance;
        } else {
            System.out.println("Initial balance cannot be negative");
        }
    }

    // 公共方法：获取余额
    public double getBalance() {
        return balance;
    }

    // 公共方法：存款
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("Deposited: " + amount);
        } else {
            System.out.println("Deposit amount must be positive");
        }
    }

    // 公共方法：取款
    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println("Withdrew: " + amount);
        } else {
            System.out.println("Invalid withdrawal amount");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        // 创建银行账户对象
        BankAccount account = new BankAccount(1000);

        // 操作账户
        account.deposit(500);        // 存款500
        account.withdraw(200);       // 取款200

        // 获取余额
        System.out.println("Current balance: " + account.getBalance());
    }
}
```

### 解释：

1. **私有属性**：`balance` 是私有的，因此其他类不能直接访问或修改它。
2. **公共方法**：我们通过 `deposit`、`withdraw` 和 `getBalance` 方法来操作和访问余额。这些方法内部控制了如何处理余额的变化，比如检查存款金额是否为正，或者检查取款金额是否超过余额。
3. **隐藏实现细节**：用户和其他类只需要知道如何调用这些方法，而不需要知道余额是如何存储和管理的。

### 总结：

封装的核心思想是 **隐藏实现细节**，只通过公共接口与外界进行交互。这样做不仅能保证数据的安全性，还使得代码更易于维护，因为你可以修改内部实现而不影响外部使用它的代码。

## 抽象类和接口的区别是什么？在什么情况下你会选择使用抽象类而不是接口？（考点：抽象类与接口的特性、使用场景）【中等】

#### 简要回答

##### 抽象类 和 接口 的概念

1. **抽象类**： 是一种**不能被实例化**的类，它**可能**包含抽象方法（没有方法体）和具体方法（有方法体）。抽象类通常是作为对应子类的基类，提供共同的属性和部分行为的实现，并强制子类实现某些特定行为。
2. **接口**： 是一种**完全抽象**的类型，接口技术用于描述类 **应该具有什么功能，但并不给出具体实现**，等到当某个类要使用接口时，再去实现接口中的这些方法。类需要遵从接口中描述的统一规则进行定义，所以，接口是对外提供的**一组规则，标准**。

##### 抽象类 和 接口 的区别

- 如下表所示：

  | **维度**     | **抽象类**                                                   | **接口**                                                     |
  | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
  | **成员变量** | 可有各种访问修饰符的实例变量、静态变量和常量。               | 默认且必须是 `public static final`（常量），且必须在定义时就初始化。 |
  | **成员方法** | 可有抽象方法（无实现）和具体方法（有实现）。抽象方法不能是 `private`, `static`, `final`。 | Java 8之前：只能有 `public abstract` 方法。 Java 8及之后：可有默认方法、静态方法。 Java 9及之后：可有私有方法。 |
  | **构造方法** | 可以有构造方法，用于子类初始化父类成员，但不能直接实例化。   | 不能有构造方法。                                             |
  | **创建对象** | 不能直接实例化。只能通过子类（非抽象）实例化。               | 不能直接实例化。只能通过实现类（非抽象）实例化，并通常通过多态引用。 |
  | **继承关系** | 使用 `extends` 关键字继承，只支持单继承。                    | 使用 `implements` 关键字实现，支持多实现（一个类可实现多个接口）。 接口之间可多继承。 |
  | **适用场景** | 表示 “is-a” 关系，作为类族共同的基类，提供模板方法模式。     | 表示 “can-do” 或 “has-a” 关系，定义行为规则/标准，实现多态，弥补单继承机制的不足。 |

------

#### 详细回答

##### 抽象类 和 接口 的概念

1. 抽象类：
   - 抽象类是Java中用于实现**抽象概念**的一种特殊类，它使用 `abstract` 关键字修饰，**不能被直接实例化**（即不能使用 `new` 关键字创建对象）。
   - 抽象类通常是作为对应子类的**基类**，提供一个通用的模板或骨架，定义一组共同的属性和部分行为，并强制子类实现某些特定的、对于每个子类来说比较特别 的行为。
2. 接口：
   - 是一种**完全抽象**的类型，它使用 `interface` 关键字定义，与抽象类类似，也不能被直接实例化。
   - 接口技术用于描述类 **应该具有什么功能，但并不给出具体实现**，等到当某个类要使用接口时，再去实现接口中的这些方法。类需要遵从接口中描述的统一规则进行定义，所以，接口是对外提供的**一组规则，标准**。
   - 接口的**主要目的**是实现**多重继承**的效果，定义不同的类可以拥有的共同的 能力或行为，强调 “做什么” 而非 “怎么做”。

##### 抽象类 和 接口 的区别

1. 成员变量：
   - **抽象类**：在抽象类中，可以定义各种类型的成员变量，包括**实例变量（非静态）、静态变量，以及静态和非静态的 常量**。这些变量可以使用**任何访问修饰符**（`public`, `protected`, `default`, `private`），并且可以 不需要被 `final` 修饰，也可以不进行初始化（因为对于实例变量，可以在构造方法中初始化）。
   - **接口**：在接口中，所有成员变量都必须是 `public static final` 类型，即**接口中没有成员变量，只有 公有静态常量** 。由于它们是常量，因此**必须在定义时进行初始化**。而因为接口不包含构造方法或静态代码块来初始化这些常量，所以定义时就进行赋值是**唯一**的初始化途径。
2. 成员方法：
   - **抽象类**： Δ 抽象类可以包含 **抽象方法** （抽象方法没有方法体，用 `abstract` 关键字修饰）和 **具体方法** （具体方法有方法体）。 Δ 抽象方法不能是 `private` 修饰的，因为私有方法无法被子类继承和实现，也不能是 `static` 修饰的，因为静态方法属于类，与实例无关，无法强制子类实现，还不能是 `final` 修饰的，因为 `final` 方法不能被重写，而抽象方法必须被重写，这就有矛盾。 Δ 具体方法（非抽象方法）则可以有任何访问修饰符，并且也可以是 `static` 或 `final`修饰的。
   - **接口**： Δ 在 **Java 8 之前**，接口中所有方法必须是 `public abstract`，即**公有的抽象方法**，不允许有方法体。事实上，接口中的方法**默认**就是**公有抽象方法**，因此在接口中定义抽象方法时，可以省略掉abstract关键字。 Δ 从 **Java 8 开始**，接口引入了 **默认方法（default methods）** 和 **静态方法（static methods）** 。默认方法使用 `default` 关键字修饰，允许接口提供方法的默认实现，实现了接口的**向后兼容性**，因为默认方法是可以被实现类重写的。静态方法使用 `static` 关键字修饰，可以通过接口名直接调用，与类中的静态方法类似。 Δ 从 **Java 9 开始**，接口进一步支持 **私有方法（private methods）** 。私有方法可以是实例方法或静态方法，它们主要用于在接口 **内部** 封装默认方法和静态方法的公共逻辑，提高代码复用性，但不能被外部或实现类直接访问。
3. 构造方法：
   - **抽象类**：抽象类可以拥有构造方法，并且支持构造方法的重载。尽管抽象类不能被直接实例化，但其构造方法会在子类实例化时被调用，用于初始化抽象类中定义的成员变量。这是因为子类的构造方法在执行时，会隐式或显式地调用其父类的构造方法。
   - **接口**：接口不能有构造方法。接口只定义行为规范和常量，不涉及实例的状态初始化，因此不需要构造方法。
4. 创建对象：
   - **抽象类**：抽象类不能直接使用 `new` 关键字创建对象（即**不能被实例化**）。要使用抽象类，必须通过其**非抽象子类**来实例化。通常，我们会通过**多态**的方式，将子类对象 赋值给 抽象类类型的**引用**，从而调用抽象类中定义的方法（包括抽象方法和具体方法）。
   - **接口**：接口也不能直接使用 `new` 关键字创建对象（即**不能被实例化**）。要使用接口，必须通过其**非抽象的实现类**来实例化。同样，通常会通过**多态**的方式，将实现类对象 赋值给 接口类型的**引用**，以实现接口定义的功能。接口的**实现类**可以是抽象类（抽象类允许部分实现接口方法）或普通类（普通类要求 必须实现接口中所有抽象方法）。
5. 继承关系：
   - **抽象类**： Δ 类与抽象类之间是**继承关系**，使用 `extends` 关键字。 Δ Java只支持**单继承**，即一个类只能继承一个抽象类（或普通类）。这使得抽象类更适合表示 “is-a” 的**强关联**关系，例如“猫是一种动物”，“程序员是一种生物”。
   - **接口**： Δ 类与接口之间 是**实现关系**，使用 `implements` 关键字。Java支持**多实现**，即**一个类可以实现多个接口**。这使得接口能够弥补Java单继承的不足，允许一个类拥有多种 不相关的“能力”或“行为”。 Δ 接口与接口之间 是**继承关系**，使用 `extends` 关键字。接口支持**多继承**，即**一个接口可以同时继承多个接口**。
6. 适用场景：
   - **抽象类**： ① 适用于表示 “is-a” 关系，我们上面也提到了，例如，当一组类之间存在共同的属性和行为，并且其中一些行为是共同实现的，而另一些行为是必须由子类各自实现的（但具体实现方式不同），这时候，就可以将子类共同的属性和行为抽象出来，把它们封装到一个抽象类中。 ② 抽象类常用于**模板方法模式**，就是定义一个操作中的算法骨架，而将一些步骤延迟到子类中去实现。
   - **接口**： ① 适用于表示 “can-do”， “has-a” ，或者 “like a” 这样一种关系，例如，当需要定义 一组不相关的类 **都必须遵循**的规则或者标准时，就可以通过接口来解决。 ② 接口经常用于实现**多态性**，使得不同类的对象能够以统一的方式被处理。 ③ 有时候需要定义一个纯粹的规范，不涉及任何实现细节时（传统接口），也可以通过定义接口来解决。 ④ 而且 从Java 8开始，有时候需要为 现有接口 添加新方法，同时还不去破坏已有的实现类时，就可以在接口中添加新的默认方法来解决。

------

#### 知识拓展

1. 接口的特性示意图如下：

   ![interfaces_info.jpg](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/7b76a36b-f1f8-48e7-9445-90e8e89d2951.jpg)

2. 面试官可能的追问1：Java 8 以后接口可以有默认方法和静态方法，这使得接口和抽象类看起来更相似了。那么，在什么情况下我仍然应该选择抽象类而不是接口？

   - 尽管Java 8引入的默认方法和静态方法增强了接口的功能，使其能够包含方法实现，从而在表面上与抽象类更加相似，但它们的核心设计理念和适用场景依然有本质区别。
   - 比方说，当已经明确了子类是父类的一种特殊类型时，抽象类显然更符合这种继承的语义；当基类需要包含实例变量（非常量）或者需要使用 `protected`、`private` 等访问修饰符的成员变量来维护状态时，那么就只能使用抽象类；当基类需要构造器来初始化其内部状态或执行一些初始化逻辑，那么也必须使用抽象类。
   - 抽象类非常适合“**模板方法模式**”，它定义了算法的**骨架**，骨架中的一些步骤由抽象类实现，而另一些抽象步骤则留给子类实现。**接口的默认方法**虽然可以提供实现，但它**更侧重于**为接口添加新功能时的兼容性，而非作为算法骨架。

3. 面试官可能的追问2：既然接口可以多继承，抽象类可以单继承，那么在设计时，什么时候优先考虑使用接口，什么时候优先考虑使用抽象类？

   - **优先使用接口（定义行为规范）**： ① 当需要定义一组**规则或标准**，而**与实现这组规则的 具体实现类的类型无关**时，往往优先用接口而不是抽象类，例如，`Runnable`（可运行的）、`Serializable`（可序列化的）。 ② 当需要实现**多重继承的效果**时，因为Java类只支持单继承，但可以实现多个接口，所以这时候可以让实现类去实现一个继承了多个接口的接口。 ③ 当项目对于耦合性比较严格时，一般更倾向于使用接口。
   - **优先使用抽象类（定义共同基类）**： Δ 具体请见 “面试官可能的追问1” 。
   - 总的来看，如果侧重于 “**做什么**”（行为），而不关心 “**怎么做**” ，选接口；如果侧重于 “**是什么**”（类型），且需要共享部分实现和状态，选抽象类。

## Java中的继承机制是如何工作的？子类能继承父类的哪些内容？（考点：继承机制、父类与子类关系、成员变量和方法继承）【简单】

**继承（Inheritance）**是面向对象编程中的一种机制，允许一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码的重用和扩展。继承的主要特点包括：

1. **父类与子类关系**：子类通过`extends`关键字继承父类，子类自动拥有父类的公共和受保护成员。

2. 成员变量和方法继承：

   - 继承的内容：子类继承父类的非私有属性和方法，包括public和protected成员。

   - **不继承的内容**：父类的构造函数、`private`成员以及`static`代码块。

3. **方法重写（Override）**：子类可以根据需要重写父类的方法，以实现不同的行为。

通过继承，子类不仅可以复用父类已有的代码，还可以在此基础上进行扩展和定制。

## 多态性在Java中是如何实现的？请举例说明。（考点：多态性、方法重写与重载、父类引用指向子类对象）【中等】

**一、多态性实现方式及示例**

1. 方法重载（Overloading）•原理：在同一个类中，方法名相同但参数列表不同（参数个数、类型或顺序不同）的方法构成重载。编译器根据调用方法时传入的参数类型和个数来决定调用哪个重载方法。• 示例：

   ```
   class Calculator {
       public int add(int a, int b) {
           return a + b;
       }
       public double add(double a, double b) {
           return a + b;
       }
   }
   ```

   • 在这个Calculator类中，有两个名为add的方法，一个接受两个int类型参数，另一个接受两个double类型参数。当调用add方法时，根据传入的参数类型不同，会调用相应的方法。

2. 方法重写（Overriding）•原理：发生在继承关系中，子类重写父类的方法，方法名、参数列表、返回值类型（从Java 5开始，返回值类型可以是父类方法返回值类型的子类型）都相同，访问权限不能更严格。运行时根据对象的实际类型来决定调用哪个类的重写方法（动态绑定）。 •示例：

   ```
   class Animal {
       public void makeSound() {
           System.out.println("Animal makes a sound");
       }
   }
   class Dog extends Animal {
       @Override
       public void makeSound() {
           System.out.println("Dog barks");
       }
   }
   class Cat extends Animal {
       @Override
       public void makeSound() {
           System.out.println("Cat meows");
       }
   }
   public class Main {
       public static void main(String[] args) {
           Animal animal1 = new Dog();
           Animal animal2 = new Cat();
           animal1.makeSound();
           animal2.makeSound();
       }
   }
   ```

   • 在这个例子中，

   ```
   Dog
   ```

   和

   ```
   Cat
   ```

   类都重写了

   ```
   Animal
   ```

   类的

   ```
   makeSound
   ```

   方法。在

   ```
   main
   ```

   方法中，虽然

   ```
   animal1
   ```

   和

   ```
   animal2
   ```

   的类型是

   ```
   Animal
   ```

   ，但实际对象分别是

   ```
   Dog
   ```

   和

   ```
   Cat
   ```

   ，所以调用

   ```
   makeSound
   ```

   方法时会根据对象的实际类型分别输出“Dog barks”和“Cat meows”。

## 说一说你对Java多态的理解。（考点：多态性）【简单】

- 事物的多种形态，比如说狗、猫都是动物这种类型的各种形态
- 多态的前提是类的**继承**和方法的**重写**
- 编译时类型和运行时类型不一致，具体来说，编译时看的是左边，运行时看的是右边，也就是**父类的引用指向子类的对象**
- 体现了一种开闭原则OCP
  - 对扩展开放，对修改关闭
  - 通俗解释：软件系统中的各种组件，如模块（Modules）、类（Classes）以及功能（Functions）等，应该在不修改现有代码的基础上，引入新功能

**【为什么需要多态？】**

在开发中，设计一个变量、或方法形参、返回值类型时，无法确定它具体的类，只能确定它是某个类型使用父类做方法的形参，是多态使用最多的场合。即使增加了新的子类，方法也无需改变，提高了扩展性，符合**开闭原则**。

**【多态的好处和弊端】**

**好处：** 父类引用子类的对象不同，执行的方法就不同，实现动态绑定。提升代码的可扩展性和灵活性

```
public class AnimalTest {
    public static void main(String[] args) {
        AnimalTest test = new AnimalTest();
        test.adopt(new Dog());  // Animal animal = new Dog();
        test.adopt(new Cat());  // Animal animal = new Cat();
    }
    //多态使用最多的场景
    public void adopt(Animal animal){
        animal.eat();
        animal.jump();
    }
   /* 有了多态就可以省略了!
      public void adopt(Dog dog){
        dog.eat();
        dog.jump();
    }*/
}
```

**弊端：** 父类变量引用子类对象时，父类变量不能访问子类中的属性和方法

```
Student m = new Student();
m.school = "pku"; 	//合法,Student类有school成员变量
Person e = new Student(); 
e.school = "pku";	//非法,Person类没有school成员变量
```

## 构造函数的作用是什么？Java中构造函数的重载是如何实现的？（考点：对象初始化、构造函数重载）【简单】

构造函数的主要作用是在创建对象时初始化对象，即为对象的成员变量赋初始值。它与类名相同，并且没有返回值类型。构造函数通常与`new`运算符一起使用，确保对象在创建时具有有效的状态。

在Java中，构造函数的重载是通过定义多个构造函数来实现的，这些构造函数的名称相同，但参数列表不同（参数的类型、数量或顺序不同）。通过构造函数重载，可以根据不同的参数来初始化对象，提供更灵活的对象创建方式。

例如，以下代码展示了如何在一个类中实现构造函数重载：

```
public class Person {
    private String name;
    private int age;

    // 默认构造函数
    public Person() {
        this.name = "未知";
        this.age = 0;
    }

    // 带一个参数的构造函数
    public Person(String name) {
        this.name = name;
        this.age = 0;
    }

    // 带两个参数的构造函数
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // 打印个人信息的方法
    public void displayInfo() {
        System.out.println("姓名: " + name + ", 年龄: " + age);
    }
}
```

在这个例子中，`Person`类有三个构造函数，分别用于不同的初始化场景。调用者可以根据需要选择合适的构造函数来创建对象。

总结： • 构造函数的作用是初始化对象。 • 构造函数重载通过定义多个参数列表不同的构造函数来实现，提供更灵活的对象创建方式。

## 静态变量和实例变量的区别是什么？静态方法呢？（考点：静态成员、实例成员、静态方法调用）【简单】

想象一下，你家里有一个**冰箱**和一堆**厨房用具**。冰箱是家里所有人都可以用的，每个人都能往里面放东西，拿东西。但是厨房用具，比如锅、刀，通常只有你自己可以用，对吧？你不能把别人家的锅拿到你家用，因为它只能在你家的厨房用。

现在，**静态变量**就像那个冰箱。无论有多少个厨房（对象）在你的家里，大家都可以共同使用它。而**实例变量**就像每个人自己用的厨房用具，每个人都有自己的一套工具。每个人使用的工具都是独立的，互不干扰。

接下来我们说说**静态方法**。它就像一个家族的烹饪秘籍，所有厨房都能用，它不关心是哪个厨房在用，因为它已经准备好给所有人使用了。你可以随时查看、使用这个方法，但它不会依赖任何一个具体的厨房（对象）来工作。

### 代码演示：

```
public class Kitchen {
    static int fridgeItems = 10;  // 静态变量：冰箱里的食材，所有厨房共享
    int personalUtensils = 5;     // 实例变量：每个厨房的独立用具

    public static void main(String[] args) {
        Kitchen kitchen1 = new Kitchen();
        Kitchen kitchen2 = new Kitchen();

        // 静态变量是共享的，所有厨房用同一个冰箱
        System.out.println("冰箱食材数: " + Kitchen.fridgeItems); // 输出 10
        Kitchen.fridgeItems = 20;
        System.out.println("冰箱食材数: " + kitchen2.fridgeItems); // 输出 20

        // 实例变量是独立的，每个厨房都有自己的用具
        System.out.println("厨房1用具数: " + kitchen1.personalUtensils); // 输出 5
        System.out.println("厨房2用具数: " + kitchen2.personalUtensils); // 输出 5
    }
}
```

### 面试官版：

**静态变量**（static variable）属于类，而不是类的实例。所有类的实例共享同一个静态变量。更改一个实例中的静态变量，其他所有实例的静态变量都会被影响。

**实例变量**（instance variable）是特定于对象的，每个对象都有自己的副本，不会影响其他对象。

**静态方法**（static method）属于类，而不是对象。静态方法只能访问静态变量和调用其他静态方法，无法访问实例变量或实例方法。

## final关键字在Java中有哪些用法？（考点：final修饰类、方法、变量、常量定义）【中等】

好比你在家里有一张“**不可更改的计划表**”，这张表上列出了你每天必须做的事情，比如“吃饭”“学习”“运动”，这些安排都已经写死了，不能随便更改。而且，如果你跟朋友分享这张表，你们都得遵守一样的安排——谁也不能随便修改它。

### 代码演示：

```
public class Plan {
    final int maxHours = 24;  // final变量：一旦设定，就不能更改

    public final void doTask() {  // final方法：不能被子类重写
        System.out.println("Doing something important!");
    }

    public static void main(String[] args) {
        Plan myPlan = new Plan();

        // final变量的使用
        System.out.println("Max hours in a day: " + myPlan.maxHours); // 输出24
        // myPlan.maxHours = 30; // 这行代码会报错，因为maxHours是final的

        // final方法的使用
        myPlan.doTask();  // 这行代码调用了final方法，不能被重写
    }
}
// final类：不能被继承
public final class ImmutablePlan {  // 这个类不能被继承
    final int maxDays = 7;  // final变量，不能修改

    public void displayPlan() {
        System.out.println("This plan cannot be changed.");
    }
}

// 下面的代码会报错：
// class ExtendedPlan extends ImmutablePlan { // 错误！不能继承final类
//     public void displayPlan() {
//         System.out.println("This is a new plan!");
//     }
// }

public class Main {
    public static void main(String[] args) {
        ImmutablePlan myPlan = new ImmutablePlan();
        myPlan.displayPlan();  // 输出：This plan cannot be changed.
    }
}
```

### 面试官版：

**`final` 关键字**可以用于三种场景：

1. **`final` 变量**：一旦赋值后，变量的值不可再改变。通常用于常量定义。
2. **`final` 方法**：方法不能被子类重写。它确保方法行为的不可变性。
3. **`final` 类**：类不能被继承，保证类的不可扩展性。

