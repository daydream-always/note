# Java 虚拟机（JVM）

![img](https://file1.kamacoder.com/i/bagu/_siweidaotu_JVM_ym.png)

## JVM 是什么？它在 Java 中扮演什么角色？

- JVM是java平台的核心组件之一，他是Java编程语言和运行java应用程序的底层操作系统之间的一个抽象层，意味着Java程序可以在任何安装了jvm的系统中运行
- 扮演的角色：
  - 字节码解释与执行：源代码（.java）通过编译器编译成字节码（.class）jvm负责加载这些字节码
  - 跨平台兼容性：jvm可以使相同的java程序可以在不同的操作系统允许
  - 内存管理：JVM包含了一个自动的垃圾收集器，用于自动管理和回收不再使用的对象所占用的内存
  - 安全管理：提供了一系列的安全特性
  - 多线程支持：支持多线程

## Java代码是如何被执行的？从编写到运行经历了哪些过程？ (考点：Java代码执行流程) 【中等】

在 Java 中写下一行 `System.out.println("Hello World");`，它的执行流程可分为以下 **7 个阶段**：

------

### 1. 编写 Java 源代码（.java）

你编写的 Java 源代码通常如下：

```
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}
```

------

### 2. 编译为字节码（.class 文件）

使用 `javac` 命令将 `.java` 文件编译为 `.class` 字节码文件：

```
javac HelloWorld.java
```

生成的 `.class` 文件不是机器代码，而是一种平台无关的字节码，交由 JVM 执行。

------

### 3. 类加载（Class Loading）

Java 虚拟机（JVM）通过 **类加载器（ClassLoader）** 加载 `.class` 字节码到内存，分为：

- **Bootstrap ClassLoader**：加载核心类（`java.lang.*`）
- **Extension ClassLoader**：加载扩展库类
- **Application ClassLoader**：加载用户类路径下的类

🔁 加载遵循 **双亲委派模型**：先委托父加载器，父加载器无法加载再由子加载器加载，防止类冲突。

------

### 4. 字节码验证、准备、解析、初始化

JVM 对类进行如下处理（类加载的五个阶段）：

| 阶段   | 说明                                   |
| ------ | -------------------------------------- |
| 加载   | 读取 .class 字节码文件                 |
| 验证   | 检查字节码合法性，防止恶意代码         |
| 准备   | 为静态变量分配内存，赋默认值           |
| 解析   | 将符号引用转为直接引用                 |
| 初始化 | 执行 `<clinit>` 方法，初始化静态变量等 |

------

### 5. 执行字节码（解释执行 / JIT 编译）

JVM 使用 **解释器（Interpreter）** 逐条翻译字节码，也可借助 **JIT 编译器（Just-In-Time Compiler）**：

- 热点代码将被即时编译成本地机器码（提高性能）
- JIT 编译器如：C1（客户端），C2（服务端）

------

### 6. 内存管理（堆、栈、方法区等）

![img](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/_Jvmneicun_anzhiruosu.png)

JVM 为程序运行划分不同内存区域：

```
┌───────────────────────┐
│ 程序计数器（线程私有） │
├───────────────────────┤
│ Java 虚拟机栈（线程私有） │
├───────────────────────┤
│ 本地方法栈（线程私有） │
├───────────────────────┤
│ 堆（线程共享）          │ ← 对象实例储存区
├───────────────────────┤
│ 方法区（元空间）        │ ← 类信息、常量等
└───────────────────────┘
```

------

### 7. 垃圾回收（Garbage Collection）

JVM 会自动回收无用对象的内存空间，常用的回收器有：

- Serial、Parallel、CMS、G1 等

------

### 总结执行流程图

![image](https://file1.kamacoder.com/i/web/2025-08-05_13-11-13.jpg)

## 解释一下JVM的跨平台性是如何实现的？ (考点：JVM跨平台性实现机制) 【中等】

Java 的 **跨平台性** 是 Java 语言最重要的特性之一，常用一句话来描述它：

> **“Write Once, Run Anywhere”**（一次编写，到处运行）

------

### 一、JVM 跨平台性的核心机制

Java 实现跨平台的关键是： 👉 **Java 程序不是直接编译为机器码，而是编译为中间代码 —— 字节码（.class 文件）**， 👉 **这些字节码由各个平台上的 Java 虚拟机（JVM）来解释或编译执行。**

------

### 二、执行流程示意图

![image](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/2025-08-05_13-19-07.jpg)

------

### 三、详细解释执行流程

| 步骤   | 说明                                                         |
| ------ | ------------------------------------------------------------ |
| ① 编写 | 使用 Java 语言编写 `.java` 源文件。                          |
| ② 编译 | 使用 Java 编译器（`javac`）将源文件编译为 `.class` 字节码文件。 |
| ③ 运行 | `.class` 文件被 JVM 加载执行，JVM 会将字节码转换为对应平台的机器码。 |

------

### 四、JVM 的平台适配机制

Java 并不是直接运行在操作系统上，而是运行在 JVM 上。每个操作系统（如 Windows、Linux、macOS）都有对应平台的 JVM 实现：

- **Windows 上的 JVM**
- **Linux 上的 JVM**
- **macOS 上的 JVM**

每个 JVM 能根据本地平台，解释/编译相同的 `.class` 字节码并运行。

------

### 五、JVM 是如何屏蔽平台差异的？

- **屏蔽不同系统的字节序、内存对齐规则等低层差异**
- **提供统一的标准库（Java API），如文件、网络、线程等，底层由本地方法实现（JNI）**
- **Java 标准库调用 native 接口时，JVM 会自动映射到平台相关实现**

------

### 六、类比理解：解释器 vs 翻译官

你可以把 JVM 看作“**翻译官**”：

- Java 程序说的是“Java 字节码”这种中间语言
- 不同的 JVM 是懂不同“国家语言”的翻译官（Windows JVM、Linux JVM）
- JVM 负责把“字节码”翻译成对应国家（平台）能听懂的语言（机器码）

------

### 总结一句话

> Java 的跨平台性是靠 **JVM + 字节码机制** 实现的。 编写一次 Java 代码，编译为字节码，任何支持 JVM 的平台都能运行，不需改动代码。

## JVM的内存结构包括哪些部分？请详细描述。 (考点：JVM内存结构) 【中等】

![image](https://file1.kamacoder.com/i/web/2025-08-05_13-26-54.jpg)

### 1. 方法区（Method Area）

- 用途：用于存储类的结构信息，例如类的元数据、常量池、静态变量、JIT 编译后的代码等。
- 特点：属于所有线程共享的内存区域。
- 说明：Java 8 以前叫方法区，HotSpot 中用永久代（PermGen）实现；Java 8 开始废弃永久代，改用元空间（Metaspace）。

### 2. 堆（Heap）

- 用途：用于存储所有对象实例和数组，是垃圾收集器（GC）管理的重点区域。
- 分代：
  - 新生代（Young Generation）
    - 包含 Eden 和两个 Survivor 区。
    - 对象刚创建时会被分配在这里。
    - Minor GC 会频繁在这里发生。
  - 老年代（Old Generation）
    - 存储生命周期较长的对象。
    - 发生 Full GC 或 Major GC。
- 特点：堆是所有线程共享的。

### 3. 程序计数器（Program Counter Register）

- 用途：当前线程所执行的字节码的行号指示器。
- 每个线程私有，用于线程切换后恢复执行位置。
- 特点：是 JVM 中唯一一个不会抛出 OOM 的内存区域。

### 4. 虚拟机栈（Java VM Stack）

- 用途：管理 Java 方法调用的运行状态，每个方法调用对应一个栈帧（Stack Frame）。
- 每个线程私有，生命周期与线程相同。
- 异常：
  - 栈空间不足会抛出 StackOverflowError；
  - 动态扩展失败会抛出 OutOfMemoryError。

### 5. 本地方法栈（Native Method Stack）

- 用途：为 Native 本地方法服务（如 C/C++ 方法）。
- 结构与虚拟机栈类似，只不过是为 native 方法而存在。
- 也可能抛出 StackOverflowError 或 OutOfMemoryError。

### 图示

![image](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/2025-08-05_13-29-11.jpg)

### 总结表格

| 区域名称              | 是否线程私有 | 主要内容                     | 异常风险            |
| --------------------- | ------------ | ---------------------------- | ------------------- |
| 方法区（Method Area） | 否           | 类元数据、常量池、静态变量等 | OOM                 |
| 堆（Heap）            | 否           | 对象实例、数组等             | OOM                 |
| 虚拟机栈（VM Stack）  | 是           | 栈帧、方法调用信息           | StackOverflow / OOM |
| 本地方法栈（Native）  | 是           | Native 方法调用信息          | StackOverflow / OOM |
| 程序计数器（PC）      | 是           | 当前线程执行字节码的地址     | 无                  |

## 堆（Heap）和栈（Stack）的区别是什么？在JVM中它们的作用分别是什么？ (考点：堆与栈的区别与作用) 【简单】

| 方面       | 堆（Heap）                           | 栈（Stack）                                    |
| ---------- | ------------------------------------ | ---------------------------------------------- |
| 存储内容   | 所有的对象实例和数组                 | 方法调用过程中的栈帧，包括局部变量、操作数栈等 |
| 生命周期   | 由垃圾回收器（GC）管理，生命周期较长 | 随方法调用进入和退出自动分配和回收             |
| 内存大小   | 较大且可动态扩展                     | 较小且固定大小                                 |
| 线程共享性 | 所有线程共享                         | 每个线程独享                                   |
| 访问速度   | 相对较慢                             | 较快                                           |
| 分配方式   | 复杂（需要GC回收）                   | 由系统自动分配释放                             |
| 典型异常   | OutOfMemoryError（内存溢出）         | StackOverflowError（栈溢出）                   |

### 堆（Heap）

- 主要用于存放Java中的对象实例（如 `new` 创建的对象）和数组。
- 是垃圾回收器管理的主要区域，负责对象的生命周期管理。
- 堆被所有线程共享，存取需要加锁或其他同步机制保证线程安全。
- 堆又细分为**新生代**和**老年代**，新生代中对象存活时间短，老年代存放生命周期长的对象。

### 栈（Stack）

- 每个线程都有自己的虚拟机栈，用于存储方法调用的状态，包括局部变量表、操作数栈、动态链接和方法返回地址。
- 栈中的数据随方法调用和结束自动分配和释放，不需要垃圾回收。
- 栈的分配和回收速度快，访问效率高。
- 当调用的方法过深或者局部变量过大，会出现栈溢出（StackOverflowError）。

------

## Java中的垃圾回收（GC）机制是如何工作的？有哪些常见的垃圾回收器？ (考点：垃圾回收机制与回收器) 【中等】

Java的自动内存管理主要针对对象内存的回收和对象内存的分配。同时，Java自动内存管理最核心的功能是**堆**内存中对象的分配与回收。

**GC机制**

- 分代回收理论：

  Java堆内存按照对象生命周期分为不同代，针对不同代采用不同回收策略

  - 新生代：存储新创建的对象，生命周期短，存活率低
  - 老年代：存储存活时间长的对象（如缓存、长生命周期对象）
  - 永久代/元空间：存储类元数据

- 垃圾对象的识别方法

  - 引用计数法：给对象添加引用计数器，引用变化时增减计数，计数为0则判定为垃圾（无法解决循环引用A->B,B->A）

  - 可达性分析：以GC Roots（如栈变量、静态变量、本地方法栈引用）为起点，遍历对象图，不可达的对象判定为垃圾，即从GC Roots到这个对象不可达（Java主流实现方式，可解决循环引用问题）

     

    ![image.png](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/16599cd6-3306-41db-931c-4bc44f11fd37.png)

- 垃圾回收算法的应用

  - 新生代：采用复制算法，因对象存活率低，少量存活对象复制代价小
  - 老年代：采用标记清除或则标记整理算法，因对象存活率高，避免频繁复制

------

**GC的工作流程：从对象创建到回收**

- **对象创建**：新对象优先分配到新生代Eden区
- Minor GC（新生代回收）
  - 触发条件：当Eden区满时触发，回收Eden和Survivor区的垃圾对象
  - 存活对象复制到Survivor区（年龄+1），当年龄超过阈值（默认15）则进入老年代
- Full GC（整堆回收）
  - 触发条件：老年代空间不足、元空间溢出、显示调用`System.gc()`等
  - 回收老年代和新生代，耗时较长，应尽量减少触发频率

------

**垃圾回收器**

- 新生代回收器

  - Serial （串行）收集器

    - 只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（"Stop The World"），直到它收集结束

      

      ![image.png](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/70dd1f6c-d489-4e38-a848-ead2c8e5b8c1.png)

  - ParNew 收集器

    - Serial 收集器的多线程版本

       

      ![image.png](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/4139fbd3-5f1c-4612-a709-2a068f217c2a.png)

  - Parallel Scavenge 收集器

    - 提供了很多参数供用户找到最合适的停顿时间或最大吞吐量

       

      ![image.png](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/2bedabec-ba71-4517-b46f-a11d403d4e04.png)

- 老年代回收器

  - Serial Old 收集器

  - Parallel Old 收集器

  - CMS（Concurrent Mark Sweep并发标记扫描）收集器

    - 一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用

       

      ![image.png](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/5a409bf9-ff50-46cb-ac90-64e135890a1d.png)

------

**【内存泄露vs内存溢出】**

**内存泄漏**：程序在运行过程中不再使用的对象仍然被引用，而无法被垃圾回收器回收，从而导致可用内存逐渐减少

**内存溢出**：Java虚拟机在申请内存时，无法找到足够的内存，最终引发内存溢出

## 介绍一下什么是强引用、软引用、弱引用、虚引用？ (考点：不同引用类型对垃圾回收的影响)【中等】

#### 强引用

在Java中最常见的引用类型，即使内存不足时，GC也不会回收强引用指向的对象。

#### 软引用

在内存不足时，GC会回收软引用指向的对象。

#### 弱引用

只要触发GC，即使内存充足，GC也会回收弱引用指向的对象。

#### 虚引用

虚引用本身并不会直接影响对象的生命周期，它必须与引用队列（ReferenceQueue）联合使用，通知线程某个对象即将死亡。这样就可以在对象被回收前做一些特定的处理（例如清理资源、记录日志等）。

## JVM中的类加载机制是怎样的？包括哪些阶段？ (考点：类加载机制与阶段) 【中等】

![img](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/_leijiazaizixitong_xiguanguoletouE.png)

.class 文件需要加载到虚拟机中之后才能运行和使用，JVM 的类加载机制是将字节码文件（.class）转化为 Java 类的过程。包含**加载、验证、准备、解析、初始化**五个阶段

- **加载：** 通过类的全限定名（如`java.lang.string`）获取字节码流，创建`class`对象
- **验证：** 确保字节码文件符合JVM规范，防止恶意代码或者错误字节码
- **准备：** 为类的静态变量分配内存并设置初始值（如`int`初始为0，`引用类型`初始为`null`）
- **解析：** 将符号引用（如`java.lang.Object`）替换为直接引用（内存地址）
- **初始化：** 执行类的初始化代码（静态代码块、静态变量赋值）

![image.png](https://gitee.com/CHENKAIforyou/image-bed/raw/master/imag/c16cf6c0-e497-463d-a655-c26feafd78ec.png)

## JVM 中的垃圾回收算法有哪些？如标记-清除、复制、标记-整理等。

JVM 垃圾回收算法是Java虚拟机中的一种自动内存管理机制，它可以自动地回收不再使用的内存空间，以便程序能够更高效地运行。JVM的垃圾回收算法主要有以下几种：

（1）标记-清除算法：该算法会先标记所有活动对象，然后清除所有未标记的对象，缺点是效率不高，无法清除垃圾碎片。

（2）复制算法：将可用内存分为两个等份，每次只使用其中一份，当这份内存用完了，就将还存活的对象复制到另一份上，然后再把已使用过的内存空间进行一次清理。

（3）标记-整理算法：该算法在标记-清除算法的基础上做了改进，即在清除无用对象的同时，将所有存活的对象向一端移动，然后直接清理掉边界以外的内存。

（4）分代收集算法：根据对象的生命周期长短将内存分为几个区域，一般分为新生代和老年代。针对这两个区域采用不同的垃圾回收算法。新生代由于对象经常消亡与诞生，所以使用复制算法。老年代则因对象存活时间长，适合使用标记整理算法。

