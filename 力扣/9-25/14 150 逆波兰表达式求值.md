## 14 150 逆波兰表达式求值

### 方法一：栈

逆波兰表达式严格遵循「从左到右」的运算。

计算逆波兰表达式的值时，

使用一个栈存储操作数，

从左到右遍历逆波兰表达式，

进行如下操作：
如果遇到操作数，则将操作数入栈；

如果遇到运算符，则将两个操作数出栈，

其中先出栈的是右操作数，

后出栈的是左操作数，

使用运算符对两个操作数进行运算，

将运算得到的新操作数入栈。

整个逆波兰表达式遍历完毕之后，

栈内只有一个元素，

该元素即为逆波兰表达式的值。

### 重点

Deque<Integer> stack = new LinkedList<Integer>();

for(int i = 0; i < n; i++){

​      String token = tokens[i];

Integer.parseInt(token)



### 知识点

这行代码的作用是声明并初始化一个**双端队列**

**（Deque，Double-Ended Queue）** 实例，

用于存储整数类型（Integer）数据。

具体解析如下：

#### 1. **`Deque<Integer>`：声明双端队列引用**

- `Deque` 是 Java 集合框架中的一个**接口**，
- 全称为 `Double Ended Queue`，即双端队列。
- 它支持在**两端**（队头和队尾）进行元素的
- 添加（`addFirst`/`addLast`）
- 和移除（`removeFirst`/`removeLast`）操作。
- `<Integer>` 是**泛型**，
- 表示该双端队列中只能存储 `Integer` 类型的数据，
- 避免存入非整数类型（如字符串、浮点数），
- 提高代码安全性和可读性。

#### 2. **`stack`：变量名**

- 命名为 `stack`，暗示该双端队列将被当作**栈**（Stack）使用。
- 栈是一种“后进先出”（LIFO）的数据结构，
- 而 `Deque` 提供了
-  `push()`（等价于 `addFirst()`）
- 和 `pop()`（等价于 `removeFirst()`）方法，
- 正好符合栈的操作逻辑（可直接用于逆波兰表达式求值等问题）。

#### 3. **`new LinkedList<Integer>()`：实例化双端队列**

- `LinkedList` 是 Java 集合框架中一个**实现了 `Deque` 接口的类**，
- 因此可以直接赋值给 `Deque<Integer>` 类型的引用（多态特性）。
- 选择 `LinkedList` 作为实现类，
- 是因为它支持高效的头部/尾部插入删除
- （时间复杂度 O(1)），
- 且无需担心容量限制（动态扩容）。

#### 作用总结

在逆波兰表达式求值等场景中，

通常需要用栈存储操作数。

这行代码通过 `Deque` 接口引用 `stack` 指向 `LinkedList` 实例，

既能通过 `Deque` 的方法（如 `push`/`pop`）实现栈的功能，

又能复用 `LinkedList` 的高效实现，

是典型的“接口面向”编程思路，

兼顾灵活性和可读性。

如果需要进一步理解“如何用 Deque 实现栈”或“逆波兰表达式中栈的具体使用”，可以告诉我哦！