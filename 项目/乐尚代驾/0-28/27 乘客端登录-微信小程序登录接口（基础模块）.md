# 27 乘客端登录-微信小程序登录接口（基础模块）

2025年 12月 09日 星期二 11:45:12 CST



- 在service-customer的CustomerInfoController

```java
@Slf4j
@RestController
@RequestMapping("/customer/info")
@SuppressWarnings({"unchecked", "rawtypes"})
public class CustomerInfoController {

   @Autowired
   private CustomerInfoService customerInfoService;

   //微信小程序登录接口
   @Operation(summary = "小程序授权登录")
   @GetMapping("/login/{code}")
   public Result<Long> login(@PathVariable String code) {
      return Result.ok(customerInfoService.login(code));
   }
}
```

@Slf4j

```java
// 使用 @Slf4j 注解相当于自动生成了以下代码：
private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(CustomerInfoController.class);
//在类的方法中可以直接使用：
log.info("用户登录成功，用户ID: {}", customerId);
log.error("登录失败，错误码: {}", errorCode);

//这样可以避免每个类都手动编写日志对象创建代码，提高开发效率。
```

@RestController

组合注解，相当于同时使用了 @Controller 和 @ResponseBody，

标记该类为Spring MVC的控制器组件，该类中所有方法的返回值都会直接作为HTTP请求的

响应体返回，而不是视图名称，方法返回值直接序列化为响应体返回

项目中是构建 RESTful API 服务，所以使用 @RestController 而不是单纯的 @Controller。

@Controller

是 Spring 框架的核心注解之一，用于标记一个类作为 MVC 模式的控制器组件，

标记的类会被 Spring 容器自动检测并注册为 Bean

传统控制器，方法返回值通常解析为视图名称

 @RequestMapping

用于定义控制器类或方法的请求的映射路径

为该类中所有请求的处理方法设置统一的路径前缀，该类中所有接口都会继承这个前缀

 @ResponseBody

用于标记控制器方法，表示该方法的返回值应直接作为 HTTP请求的响应体返回

不经过视图解析器处理，而是直接序列化为客户端所需的数据格式（如 JSON、XML）

Spring MVC 使用 HttpMessageConverter 将返回对象转换为相应的数据格式

对于 RESTful API，通常转换为 JSON 格式返回给前端

```java
// 不使用 @ResponseBody - 返回视图名称
@Controller
public class UserController {
  @GetMapping("/user")
  public String getUser(Model model) {
      model.addAttribute("user", user);
      return "user/view"; // 返回视图页面
  }
}
// 使用 @ResponseBody - 返回数据
@Controller
public class UserApiController {
  @GetMapping("/api/user")
  @ResponseBody
  public User getUser() {
      return user; // 直接序列化为 JSON 返回
  }
}
```

被controller标记的类会被 Spring 容器自动检测并注册为 Bean，这样能实现怎么样的效果？

Spring 容器负责创建和管理这些 Bean 的生命周期，无需手动使用new关键字创建对象实例

其他类可以通过 @Autowired 等注解直接注入和使用这些 Bean

实现控制反转（IoC）和依赖注入（DI）的设计模式

默认情况下，Spring Bean 采用单例模式管理，确保在整个应用中只有一个实例，节省内存

资源

Spring 容器管理 Bean 的初始化、使用和销毁过程

可以方便地应用切面编程，如事务管理、日志记录等



如果是被bean标记的方法，这样能实现怎么样的效果？

@Bean 注解标记的方法会返回一个对象实例，该实例被 Spring 容器管理，即方法的返回值

是一个对象实例，这个对象实例将成为 Spring 容器中的一个 Bean



控制反转（IoC）和依赖注入（DI）的设计模式，这是什么意思？

将对象的创建和管理控制权从程序员转移到框架或容器，实现控制权的反转



切面编程什么意思，举一个例子？

横切关注点（如日志、事务、安全等）与业务逻辑分离，实现关注点的模块化

解决代码重复问题，提高代码复用性和可维护性

```Java
// 日志切面类
@Aspect
@Component
public class LogAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(LogAspect.class);
    
    // 定义切入点：拦截 controller 包下所有类的所有方法
    @Pointcut("execution(* com.atguigu.daijia.customer.controller..*.*(..))")
    public void controllerLog() {}
    
    // 前置通知：在方法执行前记录日志
    @Before("controllerLog()")
    public void doBefore(JoinPoint joinPoint) {
        // 记录方法调用信息
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        logger.info("方法 {} 开始执行，参数: {}", methodName, Arrays.toString(args));
    }
    
    // 后置通知：在方法执行后记录日志
    @After("controllerLog()")
    public void doAfter(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        logger.info("方法 {} 执行完毕", methodName);
    }
    
    // 返回通知：方法正常返回时记录结果
    @AfterReturning(pointcut = "controllerLog()", returning = "result")
    public void doAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        logger.info("方法 {} 执行结果: {}", methodName, result);
    }
}

// 原来的 Controller 方法保持简洁
@GetMapping("/getCustomerLoginInfo/{customerId}")
public Result<CustomerLoginVo> getCustomerLoginInfo(@PathVariable Long customerId) {
    CustomerLoginVo customerLoginVo = customerInfoService.getCustomerInfo(customerId);
    return Result.ok(customerLoginVo); // 自动记录日志，无需手动添加
}
```

为什么可以直接使用 @Autowired

CustomerInfoService 接口或其实现类被标记为 Spring 组件（如 @Service），Spring 容器

在启动时会自动扫描并注册这些组件为 Bean

通常 CustomerInfoService 是一个接口，存在具体的实现类被 @Service 注解标记，Spring 

会将实现类的实例注入到接口类型的字段中



Spring 会将实现类的实例注入到接口类型的字段中，这是什么意思，举一个例子

```java
// 接口定义
public interface CustomerInfoService {
    CustomerLoginVo getCustomerInfo(Long customerId);
}

// 实现类
@Service
public class CustomerInfoServiceImpl implements CustomerInfoService {
    @Override
    public CustomerLoginVo getCustomerInfo(Long customerId) {
        // 具体实现逻辑
        return new CustomerLoginVo();
    }
}

// 控制器中使用
@RestController
public class CustomerInfoController {
    // 直接注入接口类型，Spring 自动找到实现类实例
    @Autowired
    private CustomerInfoService customerInfoService;
    
    @GetMapping("/info/{id}")
    public Result<CustomerLoginVo> getInfo(@PathVariable Long id) {
        // 调用时实际执行的是实现类的方法
        CustomerLoginVo info = customerInfoService.getCustomerInfo(id);
        return Result.ok(info);
    }
}
```





- service实现接口

```java
@Slf4j
@Service
@SuppressWarnings({"unchecked", "rawtypes"})
public class CustomerInfoServiceImpl extends ServiceImpl<CustomerInfoMapper, CustomerInfo> implements CustomerInfoService {

    @Autowired
    private WxMaService wxMaService;
    
    @Autowired
    private CustomerInfoMapper customerInfoMapper;

    @Autowired
    private CustomerLoginLogMapper customerLoginLogMapper;

    //微信小程序登录接口
    @Override
    public Long login(String code) {
        //1 获取code值，使用微信工具包对象，获取微信唯一标识openid
        String openid = null;
        try {
            WxMaJscode2SessionResult sessionInfo =
            	wxMaService.getUserService().getSessionInfo(code);
            openid = sessionInfo.getOpenid();
        }catch(WxErrorException e){
            throw new RuntimeException(e);
        }
        
        //2 根据openid查询数据库表，判断是否第一次登录
        //如果openid不存在返回null，如果存在返回一条记录
        //select * from customer_info ci where ci.wx_open_id = ''
        LambdaQueryWrapper<CustomerInfo> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(CustomerInfo::getWxOpenId,openid);
        CustomerInfo customerInfo = customerInfoMapper.selectOne(wrapper);
        
        //3 如果第一次登录，添加信息到用户表
        if(customerInfo == null) {
            customerInfo = new CustomerInfo();
			customerInfo.setNickname(String.valueOf(System.currentTimeMillis())); 										customerInfo.setAvatarUrl("https://oss.aliyuncs.com/aliyun_id_photo_bucket/default_handsome.jpg");
            customerInfo.setWxOpenId(openid);
        }
        
        //4 记录登录日志信息
        CustomerLoginLog customerLoginLog = new CustomerLoginLog();
        customerLoginLog.setCustomerId(customerInfo.getId());
        customerLoginLog.setMsg("小程序登录");
        customerLoginLogMapper.insert(customerLoginLog);
        
        //5 返回用户id
        return customerInfo.getId();
    }
}
```

为什么要使用try-catch，try-catch在什么情形下会考虑使用

wxMaService.getUserService().getSessionInfo(code) 是调用微信第三方接口的方法，可能会因

为网络问题、参数错误或微信服务器问题而抛出异常

网络请求可能超时或失败，第三方服务可能出现故障会考虑使用



这里的Session是什么意思

Session 指的是微信小程序的会话信息。当用户在微信小程序中登录时，微信服务器会生成一个

临时的会话凭证，这个 session 包含了用户的 openid 和 session_key 等信息



new CustomerInfo();，为什么还要new

当 customerInfo == null 时，表示该用户是第一次登录，数据库中没有该用户的记录，需要通过 

new 创建实际的对象实例才能调用其方法和设置属性



String.valueOf(System.currentTimeMillis())，这个是起到什么作用

生成一个唯一的昵称，默认为当前时间戳字符串。

使用时间戳确保每个新用户的昵称都不同，避免数据库中出现重复的昵称字段

在用户未设置真实昵称前提供一个占位符，后续用户可以修改为自定义昵称



为什么这个方法的最后要返回用户id

为客户端提供用户的唯一标识符，后续请求需要携带此ID进行身份验证

客户端需要用户ID来进行后续操作，如查询个人信息、下单、查看订单等都需要用户ID

前端可以将用户ID存储在本地，用于维持用户登录状态和权限控制

登录接口的标准做法是返回用户标识，便于前端进行后续的API调用和用户状态管理，符合常见的RESTful API设计模式，这是登录功能的核心输出，没有用户ID后续的所有操作都无法进行。





2025年 12月 09日 星期二 12:12:03 CST

2025年 12月 09日 星期二 14:55:23 CST

2025年 12月 09日 星期二 17:06:54 CST

2025年 12月 09日 星期二 21:30:31 CST
