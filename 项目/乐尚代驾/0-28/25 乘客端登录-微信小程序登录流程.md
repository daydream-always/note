# 25 乘客端登录-微信小程序登录流程

2025年 12月 08日 星期一 21:12:28 CST



微信小程序发起登录请求，腾讯接口返回code(临时票据)

后端接口获取code值

后端接口三个值，小程序id+秘钥+code，请求腾讯接口

腾讯接口返回信息，包含唯一标识openid

openid判断是否第一次登录，如果是第一次登录，注册

不是第一次，生成token，返回

（openid是用户在当前小程序的唯一标识，不是所有小程序的唯一。）





code是谁给的，code里面存的是什么信息，怎么存的信息？

```javascript
// 从微信服务器返回的code实际上有这些信息：
{
  "code": "031W9C8R0PWYJ919GQ9R0Q8W9C8W9C8R",
  "timestamp": 1634567890,     // 时间戳
  "appid": "wx1234567890abcdef", // 小程序ID
  "user_info": "encrypted_data",  // 加密的用户信息（需要解密）
  "iv": "iv_vector"              // 解密向量
}
```

```javascript
// 在微信内部的存储结构：
const codeStructure = {
  // 临时存储在微信服务器内存中
  code: "031W9C8R0PWYJ919GQ9R0Q8W9C8W9C8R",
  // 存储在内存中，生命周期很短
  expire_time: 600,        // 10分钟后过期
  used: false,            // 是否已经被使用
  appid: "wx1234567890abcdef", // 小程序id
  openid: "temp_openid",   // 临时openid
  timestamp: 1634567890,   // 生成时间
  signature: "xxx"         // 数字签名
}
```

为什么这样设计code？

```
code不包含用户敏感信息
用户信息需要额外解密
防止code泄露导致用户信息泄露
```

用户登录小程序，然后是微信客户端向微信服务器请求是吗？

```
用户打开小程序 → 
小程序调用 wx.login() → 
微信客户端自动向微信服务器请求 → 
微信服务器返回code → 
小程序收到code → 
小程序把code发给后端
```

为什么后端服务器要再次携带code，向微信服务器请求？

```
❌ 危险做法：
用户拿到code → 直接发给后端服务器
后端服务器直接相信这个code = 真实用户
✅ 安全做法：
用户拿到code → 发给后端服务器
后端服务器拿着code → 再次发给微信服务器验证
微信服务器确认code合法 → 返回真实用户信息

假设黑客截获了用户的code：黑客想冒充用户登录
没有二次验证：黑客拿着code直接就能登录
有二次验证：黑客的code在微信服务器上验证失败
```

为什么黑客可以拿到code，又为什么黑客的code无法通过微信服务器的验证

```
时效性检查
code = "031W9C8R0PWYJ919GQ9R0Q8W9C8W9C8R"
- 有效期：10分钟
- 如果超过时间，直接拒绝
- 黑客即使截获，也来不及使用

唯一性检查
每个code只能使用一次
微信服务器有个"code使用记录表"
- 如果code已经被使用过 → 拒绝
- 如果code从未被使用过 → 进行验证
```

完整流程

```
用户 → 小程序 → 获取code → 发给后端
后端 → 用code向微信服务器请求身份验证
微信服务器 → 验证code是否有效 + 判断是否被使用
微信服务器 → 返回真实用户标识(openid)
后端 → 收到真实信息 → 确认是可信用户
```

