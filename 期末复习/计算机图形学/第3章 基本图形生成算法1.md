# 第三章 基本图形生成算法1

2025年 12月 10日 星期三 17:18:00 CST

## 直线

- **数值微分分析法(DDA)**

k<1：

![image-20251210151516117](C:\Users\92503\AppData\Roaming\Typora\typora-user-images\image-20251210151516117.png)

用DDA扫描转换连接两点P0(0,0)和P1(5,3)的直线段，求出最佳逼近的像素点集。

x=0 时，y=0，取整后像素 (0,0)；
x=1 时，y=0+0.6=0.6，取整（0.6+0.5=1.1）得 (1,1)；
x=2 时，y=0.6+0.6=1.2，取整（1.2+0.5=1.7）得 (2,1)；
x=3 时，y=1.2+0.6=1.8，取整（1.8+0.5=2.3）得 (3,2)；
x=4 时，y=1.8+0.6=2.4，取整（2.4+0.5=2.9）得 (4,2)；
x=5 时，y=2.4+0.6=3.0，取整得 (5,3)。
最终像素点集：(0,0)、(1,1)、(2,1)、(3,2)、(4,2)、(5,3)。



k>1：

![image-20251210152323818](C:\Users\92503\AppData\Roaming\Typora\typora-user-images\image-20251210152323818.png)

![image-20251210152545063](C:\Users\92503\AppData\Roaming\Typora\typora-user-images\image-20251210152545063.png)

y=0 时，x=0，取整后像素 (0,0)；
y=1 时，x=0+1/2.5=0.4，取整（0.4+0.5=0.9）得 (0,1)；
y=2 时，x=0.4+0.4=0.8，取整（0.8+0.5=1.3）得 (1,2)；
y=3 时，x=0.8+0.4=1.2，取整（1.2+0.5=1.7）得 (1,3)；
y=4 时，x=1.2+0.4=1.6，取整（1.6+0.5=2.1）得 (2,4)；
y=5 时，x=1.6+0.4=2.0，取整得 (2,5)。
最终像素点集：(0,0)、(0,1)、(1,2)、(1,3)、(2,4)、(2,5)。



- **中点画线法**

![image-20251210153204794](C:\Users\92503\AppData\Roaming\Typora\typora-user-images\image-20251210153204794.png)

利用中点画线法计算连接 P0 (0,0) 和 P1 (5,2) 的直线段的最佳逼近像素点集及 di 的变化。

计算\(A=y_0 - y_1=0 - 2=-2\)，\(B=x_1 - x_0=5 - 0=5\)

初始判别式\(d_0=2A + B=2×(-2)+5=1\)，\(d_1=2A + 2B=2×(-2)+2×5=6\)，\(d_2=2A=-4\)

因0≤k≤1，x 为最大位移方向，x 每次递增 1。

通过判别式 d 的符号选择下一个像素，d≤0 时取 (x+1,y+1)，d>0 时取 (x+1,y)，并更新 d 

值。

初始点 (0,0)，d=1>0，下一点 (1,0)，d 更新为 1+(-4)=-3；
点 (1,0)，d=-3≤0，下一点 (2,1)，d 更新为 - 3+6=3；
点 (2,1)，d=3>0，下一点 (3,1)，d 更新为 3+(-4)=-1；
点 (3,1)，d=-1≤0，下一点 (4,2)，d 更新为 - 1+6=5；
点 (4,2)，d=5>0，下一点 (5,2)，d 更新为 5+(-4)=1。
最终像素点集：(0,0)、(1,0)、(2,1)、(3,1)、(4,2)、(5,2)；di 变化：1→-3→3→-1→5→1。

![image-20251210154543496](C:\Users\92503\AppData\Roaming\Typora\typora-user-images\image-20251210154543496.png)

\(A=y_0 - y_1=0 - 5=-5\)，\(B=x_1 - x_0=8 - 0=8\)，

初始判别式\(d_0=2A + B=2×(-5)+8=-2\)，\(d_1=2A + 2B=2×(-5)+2×8=6\)，\(d_2=2A=-10\)。

因\(0≤k≤1\)，x 为最大位移方向，x 每次递增 1。

初始点 (0,0)，d=-2≤0，下一点 (1,1)，d 更新为 - 2+6=4；
点 (1,1)，d=4>0，下一点 (2,1)，d 更新为 4+(-10)=-6；
点 (2,1)，d=-6≤0，下一点 (3,2)，d 更新为 - 6+6=0；
点 (3,2)，d=0≤0，下一点 (4,3)，d 更新为 0+6=6；
点 (4,3)，d=6>0，下一点 (5,3)，d 更新为 6+(-10)=-4；
点 (5,3)，d=-4≤0，下一点 (6,4)，d 更新为 - 4+6=2；
点 (6,4)，d=2>0，下一点 (7,4)，d 更新为 2+(-10)=-8；
点 (7,4)，d=-8≤0，下一点 (8,5)，d 更新为 - 8+6=-2。
最终像素点集：(0,0)、(1,1)、(2,1)、(3,2)、(4,3)、(5,3)、(6,4)、(7,4)、(8,5)；di 变化：-2→4→-6→0→6→-4→2→-8→-2。



- **Bresenham算法**

![image-20251210155107781](C:\Users\92503\AppData\Roaming\Typora\typora-user-images\image-20251210155107781.png)

利用 Bresenham 算法计算连接 P0 (0,0) 和 P1 (8,5) 的直线段的最佳逼近像素点集、ei 及 ei+2∆y 的变化。

![image-20251210155328962](C:\Users\92503\AppData\Roaming\Typora\typora-user-images\image-20251210155328962.png)

Bresenham 算法原理：e=e+2Δy，e>0 时取 (x+1,y+1) 且 e 更新为 e-2∆x，e≤0 时取 (x+1,y)。

先做一次正常更新e=e+2Δy，再根据更新的e判断需不需要做额外更新（起点不用被决定）

e>0 时取 (x+1,y+1) 且 e 额外更新为 e-2∆x，然后e再正常更新e=e+2Δy（e过大，要调整）

e≤0 时取 (x+1,y)，e只需正常更新e=e+2Δy

![image-20251210162116452](C:\Users\92503\AppData\Roaming\Typora\typora-user-images\image-20251210162116452.png)

利用 Bresenham 算法计算连接 P0 (2,3) 和 P1 (8,5) 的直线段的最佳逼近像素点集、ei 及 ei+2∆y 的变化。

计算Δx=8−2=6，Δy=5−3=2，初始误差e0=−Δx=−6。

因0≤k≤1，x 为最大位移方向，x 每次递增1。

初始点 (2,3)，e=-6，e=e+2∆y=-6+4=-2；



## ？

## 圆

老师的解法

![image-20251210164420556](C:\Users\92503\AppData\Roaming\Typora\typora-user-images\image-20251210164420556.png)

课本的解法

![image-20251210165634943](C:\Users\92503\AppData\Roaming\Typora\typora-user-images\image-20251210165634943.png)

已知圆的初始点为 (x0,y0)=(0,10)，用中点画圆法生成第一八分圆上的像素点坐标 (xi,yi) 和 di 的变化。

圆半径 R=10，圆心在原点，初始点 (0,10)，初始判别式\(d_0=1 - R=1 - 10=-9\)，x 初始值 0，y 初始值 10。

中点画圆法原理：第一八分圆 x 递增、y 递减或不变，d≤0 时 d 更新为 d+2x+3，点更新为 (x+1,y)；d>0 时 d 更新为 d+2 (x-y)+5，点更新为 (x+1,y-1)，直到 x≥y。

初始点 (0,10)，d=-9≤0，下一点 (1,10)，d=-9+2×0+3=-6；**（d根据当前点更新）**
点 (1,10)，d=-6≤0，下一点 (2,10)，d=-6+2×1+3=-1；
点 (2,10)，d=-1≤0，下一点 (3,10)，d=-1+2×2+3=6；
点 (3,10)，d=6>0，下一点 (4,9)，d=6+2×(3-10)+5=-3；
点 (4,9)，d=-3≤0，下一点 (5,9)，d=-3+2×4+3=8；
点 (5,9)，d=8>0，下一点 (6,8)，d=8+2×(5-9)+5=5；
点 (6,8)，d=5>0，下一点 (7,7)，d=5+2×(6-8)+5=6；
此时 x=7，y=7，x≥y，停止迭代。
第一八分圆像素点集：(0,10)、(1,10)、(2,10)、(3,10)、(4,9)、(5,9)、(6,8)、(7,7)；di 变化：-9→-6→-1→6→-3→8→5→6。

![image-20260105170659241](C:\Users\92503\AppData\Roaming\Typora\typora-user-images\image-20260105170659241.png)



## 多选

光栅图形学：**图元生成、区域填充、裁剪、反走样、消隐**等基本图形概念及其相应算法纷纷诞生。

根据光栅图形的特点，为生成直线绘制算法需要满足以下4点要求：

**①所绘制的直线要直；**

**② 所绘制的直线应该要有精确的起点和终点；**

**③ 所显示的直线的亮度或颜色要均匀，沿直线不变，且与直线的长度和方向无关；**

**④ 直线生成的速度要快。还能处理不同线宽、颜色、线型。**



直线方程类型：**点斜式、斜截式、两点式、截距式和一般式**。

圆的方程类型：**标准方程、‌一般方程、‌参数方程**等。

在光栅图形学研究中，已经有很多成熟的直线扫描转换算法，具体包括有：**逐点比较法、正负法**、**数值微分分析法（DDA）、中点画线法、Bresenham算法**

在光栅图形学研究中，已经有很多成熟的圆的扫描转换算法，具体包括有：**数值微分分析算法（DDA）、中点画圆法、Bresenham算法**

如何绘制具有一定宽度的直线和圆弧？获得具有指定宽度的线，通常有两类方法：**（1）刷子绘制法；（2）实区域填充法**

（1）刷子绘制法：**①线刷子；②方形刷子**



在DDA算法中，下面哪些是正确的论述：A. 采用了直线的两点式方程、**B. 引入了增量思想、C. 采用了直线斜截式方程**、D. DDA算法效率提高到整数加法

有关中点画线算法的正确论述：**A. 采用了直线一般式方程**、B. 在效率上和DDA算法一样、**C. 为了实现整数加法，采用了判符号的方法**、**D. 和DDA算法一样，采用了增量思想**

Bresenham算法改进一：，Bresenham算法不需要看e的大小，只看e的符号。与中点画线算法十分相似、Bresenham算法改进二：由于算法中只用到误差项的符号，可以用e*2*∆x来替换e

比较DDA算法、中点画线算法以及Bresenham算法：（1）DDA算法原理比较简单，但因为涉及浮点运算和舍入取整运算，因此不利于用硬件实现。（2）中点算法和Bresenham算法都隐含着对逼近过程中误差项的处理，这就使得直线生成更精确，只有加减法和乘2运算（可通过位移实现），因此算法实现速度快，效率高。（3）Bresenham算法集中了DDA算法和中点算法两个算法的优点，而且应用范围广泛。

八分法画圆：利用圆的标准方程的缺点：乘方运算，开方运算；利用圆的参数极坐标方程的缺点：乘法运算、三角函数运算

圆的扫描转换算法：由于DDA算法生成的圆并不精确，并且设计浮点数运算，因此，DDA画圆算法并不常用。与八分法画圆一样，最大位移是x方向！x每次增加1，y减少1或者不变。





/**

**图元生成、区域填充、裁剪、反走样、消隐**

**①所绘制的直线要直；**

**② 所绘制的直线应该要有精确的起点和终点；**

**③ 所显示的直线的亮度或颜色要均匀，沿直线不变，且与直线的长度和方向无关；**

**④ 直线生成的速度要快。还能处理不同线宽、颜色、线型。**

**点斜式、斜截式、两点式、截距式和一般式**。

**标准方程、‌一般方程、‌参数方程**

**逐点比较法、正负法**、**数值微分分析法（DDA）、中点画线法、Bresenham算法**

**数值微分分析算法（DDA）、中点画圆法、Bresenham算法**

**（1）刷子绘制法；（2）实区域填充法**

**①线刷子；②方形刷子**

*/

/**

**图元生成、区域填充、裁剪、反走样、消隐**

**①所绘制的直线要直；**

**② 所绘制的直线应该要有精确的起点和终点；**

**③ 所显示的直线的亮度或颜色要均匀，沿直线不变，且与直线的长度和方向无关；**

**④ 直线生成的速度要快。还能处理不同线宽、颜色、线型。**

**点斜式、斜截式、两点式、截距式和一般式**。

**标准方程、‌一般方程、‌参数方程**

**逐点比较法、正负法**、**数值微分分析法（DDA）、中点画线法、Bresenham算法**

**数值微分分析算法（DDA）、中点画圆法、Bresenham算法**

**（1）刷子绘制法；（2）实区域填充法**

**①线刷子；②方形刷子**

*/

/**

**①所绘制的直线要直；**

**② 所绘制的直线应该要有精确的起点和终点；**

**③ 所显示的直线的亮度或颜色要均匀，沿直线不变，且与直线的长度和方向无关；**

**④ 直线生成的速度要快。还能处理不同线宽、颜色、线型。**

**点斜式、斜截式、两点式、截距式和一般式**。

**标准方程、‌一般方程、‌参数方程**

**逐点比较法、正负法**、**数值微分分析法（DDA）、中点画线法、Bresenham算法**

**数值微分分析算法（DDA）、中点画圆法、Bresenham算法**

**（1）刷子绘制法；（2）实区域填充法**

**①线刷子；②方形刷子**

*/



## 单选

当显示器的分辨率较低时，这条直线存在锯齿的形状。也称为阶梯效应或走样。

如何把数学上的一个点扫描转换一个屏幕像素点？x和y分别加0.5，再取整

在一个迭代算法中，如果每一步的x、y值是用前一步的值加上一个增量来获得的，那么，这种算法就称为增量算法。

DDA算法缺点：有浮点数和浮点运算，取整运算，效率并不高。

中点画线法它的基本思想是从线段的起点和终点出发，按照一定的规则向终点逐步逼近，并在途中以控制变量的方式得出每个像素点的坐标，从而绘制出所需的线条。

中点画线法每次在最大位移方向上走一步，而另一个方向是走步还是不走步要取决于中点误差项的判断。

中点画线法通过中点与直线的位置关系引入误差项d，判断误差项的符号来选择候选点。

中点生成直线的算法提高到了整数加法，优于DDA算法。





## 判断

逼近的过程本质上可以认为是：连续量向离散量的转换

在光栅扫描显示器上，通常用有序数对(x,y)表示像素的索引

光栅图形中的点（像素）则是占据一定的空间区域，是有面积的。

多数显示系统中像素的形状呈水滴状或正方形

只有找出像素二维编址和帧缓冲存储器中存储单元一维编址之间的映射关系，才能将像素(x,y)与帧缓冲存储单元地址建立唯一的对应关系，实现帧缓冲存储器的存取操作，进而可以在屏幕上显示该像素。

每个像素点的（xy）坐标都必须是整型的数据。

y=kx+b算法中存在一次浮点乘法和一次取整运算

在计算机运算当中，加法运算是最快的。

DDA把原来一个乘法和加法变成了一个加法

DDA算法是一个增量算法

DDA算法把效率提高到每步只做一个浮点加法，中点算法进一步把效率提高到每步只做一个整数加法







